<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>无常是常</title>
  
  
  <link href="https://www.buzhidao.cc/atom.xml" rel="self"/>
  
  <link href="https://www.buzhidao.cc/"/>
  <updated>2025-06-30T05:56:01.526Z</updated>
  <id>https://www.buzhidao.cc/</id>
  
  <author>
    <name>kim</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用构建脚本</title>
    <link href="https://www.buzhidao.cc/2025/06/15/%E5%B8%B8%E7%94%A8%E6%9E%84%E5%BB%BA%E8%84%9A%E6%9C%AC/"/>
    <id>https://www.buzhidao.cc/2025/06/15/%E5%B8%B8%E7%94%A8%E6%9E%84%E5%BB%BA%E8%84%9A%E6%9C%AC/</id>
    <published>2025-06-15T04:02:33.000Z</published>
    <updated>2025-06-30T05:56:01.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="镜像构建脚本">镜像构建脚本</h2><p>build-image-web.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [ &quot;$&#123;BUILD_DIR&#125;&quot; == &quot;&quot; ];then</span><br><span class="line">    echo &quot;env &#x27;BUILD_DIR&#x27; is not set&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">DOCKER_DIR=$&#123;BUILD_DIR&#125;/$&#123;JOB_NAME&#125;</span><br><span class="line"></span><br><span class="line">if [ ! -d $&#123;DOCKER_DIR&#125; ];then</span><br><span class="line">    mkdir -p $&#123;DOCKER_DIR&#125;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;docker workspace: $&#123;DOCKER_DIR&#125;&quot;</span><br><span class="line"></span><br><span class="line">JENKINS_DIR=$&#123;WORKSPACE&#125;/$&#123;MODULE&#125;</span><br><span class="line"></span><br><span class="line">echo &quot;jenkins workspace: $&#123;JENKINS_DIR&#125;&quot;</span><br><span class="line"></span><br><span class="line">PROJECT_DIR=$&#123;JENKINS_DIR&#125;$&#123;JOB_NAME&#125;-web</span><br><span class="line"></span><br><span class="line">echo &quot;project workspace: $&#123;PROJECT_DIR&#125;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [ ! -f $&#123;PROJECT_DIR&#125;/target/*.jar ];then</span><br><span class="line">    echo &quot;target jar file not found $&#123;PROJECT_DIR&#125;/target/*.jar&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cd $&#123;DOCKER_DIR&#125;</span><br><span class="line">rm -fr *.jar Dockerfile</span><br><span class="line"></span><br><span class="line">DOCKER_FILE=/opt/script/Dockerfile</span><br><span class="line"></span><br><span class="line">cp $&#123;PROJECT_DIR&#125;/target/*.jar .</span><br><span class="line">cp $&#123;DOCKER_FILE&#125; .</span><br><span class="line"></span><br><span class="line">sed -i &quot;s,&#123;&#123;JOB_NAME&#125;&#125;,$&#123;JOB_NAME&#125;,g&quot; Dockerfile</span><br><span class="line"></span><br><span class="line">VERSION=$(date +%Y%m%d%H%M%S)</span><br><span class="line"></span><br><span class="line">IMAGE_NAME=harbor.merchant.com/kubernetes/$&#123;JOB_NAME&#125;:$&#123;VERSION&#125;</span><br><span class="line"></span><br><span class="line">echo &quot;$&#123;IMAGE_NAME&#125;&quot; &gt; $&#123;WORKSPACE&#125;/IMAGE</span><br><span class="line"></span><br><span class="line">echo &quot;building image: $&#123;IMAGE_NAME&#125;&quot;</span><br><span class="line">docker build -t $&#123;IMAGE_NAME&#125; .</span><br><span class="line"></span><br><span class="line">docker push $&#123;IMAGE_NAME&#125;</span><br><span class="line"></span><br><span class="line">helm list -n default</span><br><span class="line">helm upgrade $&#123;JOB_NAME&#125; --set name=$&#123;JOB_NAME&#125; --set version=$VERSION --set httpPorts=8080  -n default  /opt/charts/</span><br></pre></td></tr></table></figure><h2 id="Dockerfile">Dockerfile</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> LANG en_US.UTF-<span class="number">8</span></span><br><span class="line"><span class="keyword">ENV</span> LANGUAGE en_US:en</span><br><span class="line"><span class="keyword">ENV</span> LC_ALL en_US.UTF-<span class="number">8</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">ENV</span> apollo.meta http://<span class="number">192.168</span>.<span class="number">3.183</span>:<span class="number">8080</span></span><br><span class="line"><span class="keyword">ENV</span> APOLLO_LABEL XianDevLabel</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> &#123;&#123;JOB_NAME&#125;&#125;.jar /&#123;&#123;JOB_NAME&#125;&#125;.jar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-Dapollo.label=XianDevLabel&quot;</span>,<span class="string">&quot;-Djava.security.egd=file:/dev/./urandom&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;&#123;&#123;JOB_NAME&#125;&#125;.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;镜像构建脚本&quot;&gt;镜像构建脚本&lt;/h2&gt;
&lt;p&gt;build-image-web.sh&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;</summary>
      
    
    
    
    <category term="脚本" scheme="https://www.buzhidao.cc/categories/%E8%84%9A%E6%9C%AC/"/>
    
    
    <category term="shell" scheme="https://www.buzhidao.cc/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>mermaid</title>
    <link href="https://www.buzhidao.cc/2025/06/11/mermaid/"/>
    <id>https://www.buzhidao.cc/2025/06/11/mermaid/</id>
    <published>2025-06-11T14:11:19.000Z</published>
    <updated>2025-06-30T07:43:56.771Z</updated>
    
    <content type="html"><![CDATA[<p>Mermaid 图表展示</p><p>这是一个展示Mermaid图表功能的文章，同时也演示了目录功能。</p><h2 id="思维导图-mindmap">思维导图 (mindmap)</h2><pre class="mermaid">mindmap  root((mindmap))    Origins      Long history      ::icon(fa fa-book)      Popularisation        British popular psychology author Tony Buzan    Research      On effectiveness<br/>and features      On Automatic creation        Uses            Creative techniques            Strategic planning            Argument mapping    Tools      Pen and paper      Mermaid</pre><h2 id="状态图-stateDiagram">状态图 (stateDiagram)</h2><pre class="mermaid">stateDiagram-v2    [*] --> Still    Still --> [*]    Still --> Moving    Moving --> Still    Moving --> Crash    Crash --> [*]</pre><h2 id="类图-classDiagram">类图 (classDiagram)</h2><pre class="mermaid">classDiagram    Animal <|-- Duck    Animal <|-- Fish    Animal <|-- Zebra    Animal : +int age    Animal : +String gender    Animal: +isMammal()    Animal: +mate()    class Duck{      +String beakColor      +swim()      +quack()    }    class Fish{      -int sizeInFeet      -canEat()    }    class Zebra{      +bool is_wild      +run()    }</pre><h2 id="象限图-quadrantChart">象限图 (quadrantChart)</h2><pre class="mermaid">quadrantChart    title Reach and engagement of campaigns    x-axis Low Reach --> High Reach    y-axis Low Engagement --> High Engagement    quadrant-1 We should expand    quadrant-2 Need to promote    quadrant-3 Re-evaluate    quadrant-4 May be improved    Campaign A: [0.3, 0.6]    Campaign B: [0.45, 0.23]    Campaign C: [0.57, 0.69]    Campaign D: [0.78, 0.34]    Campaign E: [0.40, 0.34]    Campaign F: [0.35, 0.78]</pre><h2 id="流程图示例">流程图示例</h2><h2 id="简单流程图">简单流程图</h2><pre class="mermaid">flowchart TD    A[开始] --> B{是否有条件}    B -->|是| C[执行操作A]    B -->|否| D[执行操作B]    C --> E[结束]    D --> E</pre><h2 id="复杂流程图">复杂流程图</h2><pre class="mermaid">flowchart LR    A[用户请求] --> B[身份验证]    B -->|成功| C[处理请求]    B -->|失败| D[返回错误]    C --> E[数据库查询]    E --> F[数据处理]    F --> G[返回结果]</pre><h2 id="甘特图示例">甘特图示例</h2><pre class="mermaid">gantt    section Section    Completed :done,    des1, 2014-01-06,2014-01-08    Active        :active,  des2, 2014-01-07, 3d    Parallel 1   :         des3, after des1, 1d    Parallel 2   :         des4, after des1, 1d    Parallel 3   :         des5, after des3, 1d    Parallel 4   :         des6, after des4, 1d</pre><h2 id="时序图示例">时序图示例</h2><pre class="mermaid">sequenceDiagramAlice->>John: Hello John, how are you?loop HealthCheck    John->>John: Fight against hypochondriaendNote right of John: Rational thoughts!John-->>Alice: Great!John->>Bob: How about you?Bob-->>John: Jolly good!</pre><h2 id="C4">C4</h2><pre class="mermaid">C4Contexttitle System Context diagram for Internet Banking SystemPerson(customerA, "Banking Customer A", "A customer of the bank, with personal bank accounts.")Person(customerB, "Banking Customer B")Person_Ext(customerC, "Banking Customer C")System(SystemAA, "Internet Banking System", "Allows customers to view information about their bank accounts, and make payments.")Person(customerD, "Banking Customer D", "A customer of the bank, <br/> with personal bank accounts.")Enterprise_Boundary(b1, "BankBoundary") {  SystemDb_Ext(SystemE, "Mainframe Banking System", "Stores all of the core banking information about customers, accounts, transactions, etc.")  System_Boundary(b2, "BankBoundary2") {    System(SystemA, "Banking System A")    System(SystemB, "Banking System B", "A system of the bank, with personal bank accounts.")  }  System_Ext(SystemC, "E-mail system", "The internal Microsoft Exchange e-mail system.")  SystemDb(SystemD, "Banking System D Database", "A system of the bank, with personal bank accounts.")  Boundary(b3, "BankBoundary3", "boundary") {    SystemQueue(SystemF, "Banking System F Queue", "A system of the bank, with personal bank accounts.")    SystemQueue_Ext(SystemG, "Banking System G Queue", "A system of the bank, with personal bank accounts.")  }}BiRel(customerA, SystemAA, "Uses")BiRel(SystemAA, SystemE, "Uses")Rel(SystemAA, SystemC, "Sends e-mails", "SMTP")Rel(SystemC, customerA, "Sends e-mails to")</pre><h2 id="Journey">Journey</h2><pre class="mermaid">  journey    title My working day    section Go to work      Make tea: 5: Me      Go upstairs: 3: Me      Do work: 1: Me, Cat    section Go home      Go downstairs: 5: Me      Sit down: 3: Me</pre><h2 id="Bar-Chart">Bar Chart</h2><pre class="mermaid">gantt    title Git Issues - days since last update    dateFormat  X    axisFormat %s    section Issue19062    71   : 0, 71    section Issue19401    36   : 0, 36    section Issue193    34   : 0, 34    section Issue7441    9    : 0, 9    section Issue1300    5    : 0, 5</pre><h2 id="Git-Graph">Git Graph</h2><pre class="mermaid">gitGraph  commit  commit  branch develop  checkout develop  commit  commit  checkout main  merge develop  commit  commit</pre><h2 id="Pie">Pie</h2><pre class="mermaid">pie"Dogs" : 386"Cats" : 85.9"Rats" : 15</pre><h2 id="总结">总结</h2><p>通过以上示例，我们可以看到Mermaid支持多种类型的图表：</p><ul><li>思维导图：用于整理思路和概念</li><li>状态图：用于描述系统状态变化</li><li>类图：用于展示类之间的关系</li><li>象限图：用于分析和分类</li><li>流程图：用于描述业务流程</li><li>时序图：用于展示交互过程</li></ul><p>这些图表都可以通过简单的文本语法来创建，非常适合技术文档和博客文章。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Mermaid 图表展示&lt;/p&gt;
&lt;p&gt;这是一个展示Mermaid图表功能的文章，同时也演示了目录功能。&lt;/p&gt;
&lt;h2 id=&quot;思维导图-mindmap&quot;&gt;思维导图 (mindmap)&lt;/h2&gt;
&lt;pre class=&quot;mermaid&quot;&gt;mindmap
  root((m</summary>
      
    
    
    
    <category term="mermiad" scheme="https://www.buzhidao.cc/categories/mermiad/"/>
    
    
    <category term="mermaid" scheme="https://www.buzhidao.cc/tags/mermaid/"/>
    
  </entry>
  
  <entry>
    <title>2025摘抄</title>
    <link href="https://www.buzhidao.cc/2025/01/01/2025%E6%91%98%E6%8A%84/"/>
    <id>https://www.buzhidao.cc/2025/01/01/2025%E6%91%98%E6%8A%84/</id>
    <published>2025-01-01T09:58:42.000Z</published>
    <updated>2025-07-02T06:42:14.637Z</updated>
    
    <content type="html"><![CDATA[<p>2025/02/08</p><p>一念放下，天地皆宽。那些强求不放的事，都会成为自己的深渊</p><blockquote><p>蒲松龄写过一个执迷象棋的书生。书生途经扬州时，见一位梁将军在林子里喝酒下棋，便徘徊棋桌旁，不愿离去。<br>梁将军邀请他下一盘，一连三局，书生都败下阵来。书生不服气，一直下到夜幕降临。<br>就在这时，忽然一阵阴风扫过，书生竟跪地痛哭，拉着梁将军的衣角，求他救救自己。<br>原来，书生早已做鬼。他生前执迷于下棋，荒废了学业。家里打也打了，骂也骂了，可书生就是割舍不下。<br>他把父亲活活气死，因“大不孝”的罪名被阎王索了性命，打入饿鬼狱。<br>因他颇有才华，阎王又派他给东岳大帝的凤楼写碑文，如果写好了，可放他还阳。<br>结果在前往凤楼的路上，书生巧遇梁将军的棋局，执念再起，耽误了行程。阎王知道后，任是谁来求情，都不再宽恕他。<br>这两个故事告诉我们，<strong>无论是对物质的贪恋，还是对成就的追求，一旦成为执念，就会变成心灵的枷锁。</strong></p></blockquote><p>2025/02/21</p><p>不纠结过河的筏子</p><p>不迷恋肉身。既不迷恋自己的肉身，也不迷恋身边人的肉<br>身。无论如何青春的肉体终会消逝，可以珍惜的时候就要好好珍惜，<br>能够展现的时候就要尽情展现，不要等到肉身衰老，禽兽无能，眼前<br>花盛开，鸟却飞不起来，才后悔莫及。  — 冯唐</p><p>2025/04/25</p><p>人生没有意义，它才自由，没意义不等于摆烂，什么都不做。</p><p>一朵花开在山里无人问津，另外一朵花被搬进奢华的房间，他们都还是花，一个活成了别人想要的样子，另一个无拘无束，活成了自己想要的样子 ——— 致人生的意义</p><p>空白才有无限可能！回归内心的空白，结果不是自我价值的终身判决。当你不需要意义证明自己时，反而变得更有力量，激发出更纯粹的创造力，不要沉迷于别人定义好的路，<br>每个人有自己的路，不需要你去拯救或者批判，做好自己就好</p><p>2025/07/02<br>“唐肃宗乾元年间，录事薛某高烧中梦见自己变成一条金色鲤鱼，几日不曾觅食，肚中甚是饥饿。此时，正遇一渔夫垂钓，他明知饵里有钩，却耐不住饵香扑鼻，张口吞饵，结果被渔翁钓了上来。” ————《醒世恒言》第26卷《薛录事鱼服证仙》</p><p>欲望是处处都是陷阱。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2025/02/08&lt;/p&gt;
&lt;p&gt;一念放下，天地皆宽。那些强求不放的事，都会成为自己的深渊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;蒲松龄写过一个执迷象棋的书生。书生途经扬州时，见一位梁将军在林子里喝酒下棋，便徘徊棋桌旁，不愿离去。&lt;br&gt;
梁将军邀请他下一盘，一连三局，</summary>
      
    
    
    
    <category term="摘抄" scheme="https://www.buzhidao.cc/categories/%E6%91%98%E6%8A%84/"/>
    
    
    <category term="摘抄" scheme="https://www.buzhidao.cc/tags/%E6%91%98%E6%8A%84/"/>
    
  </entry>
  
  <entry>
    <title>2024摘抄</title>
    <link href="https://www.buzhidao.cc/2024/12/31/2024%E6%91%98%E6%8A%84/"/>
    <id>https://www.buzhidao.cc/2024/12/31/2024%E6%91%98%E6%8A%84/</id>
    <published>2024-12-31T09:55:20.000Z</published>
    <updated>2025-06-12T09:57:52.147Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://xiaohu.ai/p/14455">采访当今最伟大的数学家对AI的看法 陶哲轩：我们正踏入数学的全新领域 – XiaoHu.AI学院</a></p><blockquote><p>我对重复人类已经擅长的事情并不感兴趣。这看起来效率低下。我认为在前沿领域，人类和AI将始终是必需的。它们有互补的优势。AI擅长将数十亿条数据转化为一个好的答案。人类擅长通过10次观察作出非常有创意的猜测。</p></blockquote><p>2024/10/22</p><p><strong>这是我们之间的故事，它代表的是一种特殊的意义（致不完美）</strong></p><p>2024/10/25</p><p><strong>王阳明曾说：“吾辈用功，只求日减，不求日增。减得一分人欲，便是复得一分天理，何等轻快洒脱，何等简易。</strong>”</p><p>我们应该定期清理卫生，只留下必需品，久而久之你就会发现，原来很多东西只是一个摆设，并非我们所需。</p><blockquote><p><strong>我们应该定期审视人生，这样才会发现，原来那些占据自己精力的东西，实际上毫无价值。</strong></p></blockquote><p>**都说人生从来不是加法，而是减法。**只有不断地抛弃一些不必要的东西，内心才不会被遮蔽，光照进来，才能看清自己内心真正需要的是什么。</p><p><strong>懂得知足，才能常乐</strong></p><p>欲望越膨胀，人类越得不到满足，这便是痛苦的根源。只有懂得知足，才能真正获得财富。</p><p>着相了</p><p><a href="https://m.baidu.com/from=844b/ssid=0/s?word=%E7%9D%80%E7%9B%B8&amp;sa=re_dqa_generate&amp;ms=1&amp;rqid=9536758797780036267&amp;params_ssrt=node-san">**着相</a>是一个‌<a href="https://m.baidu.com/from=844b/ssid=0/s?word=%E4%BD%9B%E6%95%99&amp;sa=re_dqa_generate&amp;ms=1&amp;rqid=9536758797780036267&amp;params_ssrt=node-san">佛教</a>术语，意思是执着于外相、虚相或个体意识而偏离了本质。**</p><p>2024/10/29</p><p><strong>事上练</strong></p><p>只有日常中多注意在事上的磨练，在各种事情上锻炼自己的应变能力，让自己心境逐渐处在一种十分稳定的状态下，只有这样才能锻炼出遇事不慌不乱的素质。</p><p>“熟能生巧，巧能生化”。在社会浮躁风气渐盛的今天，笃行恰恰是我们最应该学习的。</p><p><strong>笃行</strong></p><p>王阳明有句话：“辨即明矣，思既慎矣，问既审矣，学既能矣，又从而不息其功焉，斯之谓笃行。”意思是，当我们已经分辨清楚，思考缜密，问得详细，已经学会了，还是持续不断地用功，这就叫笃行，这是获得成功的必要前提。</p><p>2024/10/30</p><p><strong>君子得失淡然，所以有终身之乐；小人患得患失，所以无一日之乐。</strong></p><p>2024/11/7</p><p><strong>淡定看人生，宁静做自我。</strong></p><p><strong>所谓定力，实为定心，心静了，生活自然也就安稳了，人生自然也就安定了。</strong></p><p>反之，无法保持内心的宁静，则容易被情绪所控制，稍不注意就可能误入歧途、贻误终生。</p><p><strong>忍一时风平浪静，退一步海阔天空。想开了，自然微笑；看透了，肯定放下。这样才能在“风雨人生路上，逍遥任我行。”</strong></p><p>2024/11/12</p><p>第一性原理（First Principles Thinking）是一种思维方法，指的是把问题分解到最基本的真理上，从最基本的层面去思考问题，而不是基于类比或现有经验。</p><p>让我用一个简单的编程例子来说明：假设我们需要计算一个购物车的总价格。</p><p><strong>传统思维方式</strong></p><p>：直接参考其他电商网站的实现方式，复制他们的解决方案。</p><p><strong>第一性原理思维</strong></p><p>：</p><ul><li>首先分析问题的本质：</li><li>购物车是什么？ → 商品的集合</li><li>总价格是什么？ → 所有商品价格的总和</li><li>每个商品的价格如何计算？ → 单价 × 数量</li></ul><ol start="2"><li>基于这些基本事实来设计解决方案：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CartItem</span>:</span><br><span class="line">    def <span class="title function_">__init__</span><span class="params">(self, name, price, quantity)</span>:</span><br><span class="line">        self.name = name</span><br><span class="line">        self.price = price</span><br><span class="line">        self.quantity = quantity</span><br><span class="line">    </span><br><span class="line">    def <span class="title function_">get_total</span><span class="params">(self)</span>:</span><br><span class="line">        <span class="keyword">return</span> self.price * self.quantity</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShoppingCart</span>:</span><br><span class="line">    def <span class="title function_">__init__</span><span class="params">(self)</span>:</span><br><span class="line">        self.items = []</span><br><span class="line">    </span><br><span class="line">    def <span class="title function_">add_item</span><span class="params">(self, item)</span>:</span><br><span class="line">        self.items.append(item)</span><br><span class="line">    </span><br><span class="line">    def <span class="title function_">calculate_total</span><span class="params">(self)</span>:</span><br><span class="line">        <span class="keyword">return</span> sum(item.get_total() <span class="keyword">for</span> item in self.items)</span><br></pre></td></tr></table></figure><p>通过第一性原理思维，我们：</p><ul><li>没有直接抄袭现有解决方案</li><li>从最基本的概念出发（商品、数量、价格）</li><li>构建出了清晰、可维护的解决方案</li></ul><p>这种思维方式让我们能够：</p><ul><li>更深入地理解问题</li><li>创造出更优的解决方案</li><li>避免被既有思维定式限制</li></ul><p>马斯克就经常使用第一性原理思维。比如在设计特斯拉电池时，他没有直接采用现有的电池方案，而是从最基本的材料成本和物理原理出发，重新思考了电池的设计，最终降低了成本并提高了性能。</p><p>2024/11/17</p><p>非淡泊无以明志，非宁静无以致远 —诸葛亮《诫子书》</p><p>2024/12/10</p><p>立志、勤学、改过、责善</p><p>为什么立志如此重要？王阳明举例说，一个人如果没有志向，那么就好像船没有舵木、马没有衔环，于是只能随波逐流，人生就如一盘散沙。</p><p>非学无以广才，非志无以成学</p><p>如果不通过学习，就无法增长才干；如果没有志向，就无法成就学问。</p><p>2024/12/26</p><p>如何才能做到在工作和生活中诚意满满？<br>第一，搞清楚你的工作性质：这份工作到底是在做什么？它能给别人带来什么益处？<br>第二，紧盯着那个“益处”，并且专心致志地放大它。<br>第三，把工作和生活紧密结合，真心实意地对待你的工作和生活。</p><p>2024/12/27</p><p>每天前进三十公里 ——南极探险的故事</p><p>2024/12/29</p><p>人生在世，不是每日往复，应该想想来到这个世间的道理？ 寻求自己的答案</p><p>《穷爸爸也富爸爸》普通人只能被日复一日推着走</p><p>被金钱支配的恐惧和欲望</p><p>金钱的本质是流动</p><p>不要为钱打工，要让钱为你打工</p><p><strong>首先要思考上班的意思是什么？上班是为了赚钱？那赚钱的方式只有上班吗？上班时最优解吗？还是说上班只是当下临时方案？</strong></p><p>2024/12/31</p><p>人活一世，到底为了什么？是为了功名利禄、权势尊位，还是传宗接代、子孙满堂？</p><p><strong>王阳明说，是为了心安。而心安的唯一来源便是人与生俱来的良知。除却良知，一切都是梦幻泡影。</strong></p><p>一个杯子，里面有半杯水。有人描述这杯中还有半杯水，而有人会说这里只有半杯水了。前者是乐观主义者，后者是悲观主义者。<br>有句话叫“悲观者往往正确，乐观者往往成功”。大意是说，悲观者意识到一件事的成功率不高时，就会拒绝行动，从概率角度来看，这是正确的。但乐观者往往会关注事物积极的一方面，即使意识到一件事的成功率不高，只要回报足够，也倾向于迎难而上；不管多难的事，只要有所实践，离成功便更近一步，再加上点儿运气及坚持到底的乐观心态，往往就成功了</p><p>此心安处是吾乡，心安才是良知！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://xiaohu.ai/p/14455&quot;&gt;采访当今最伟大的数学家对AI的看法 陶哲轩：我们正踏入数学的全新领域 – XiaoHu.AI学院&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我对重复人类已经擅长的事情并不感兴趣。这看起来效率低下。</summary>
      
    
    
    
    <category term="摘抄" scheme="https://www.buzhidao.cc/categories/%E6%91%98%E6%8A%84/"/>
    
    
    <category term="摘抄" scheme="https://www.buzhidao.cc/tags/%E6%91%98%E6%8A%84/"/>
    
  </entry>
  
  <entry>
    <title>事务到底是隔离的还是不隔离的？</title>
    <link href="https://www.buzhidao.cc/2022/06/12/%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%98%E6%98%AF%E4%B8%8D%E9%9A%94%E7%A6%BB%E7%9A%84%EF%BC%9F/"/>
    <id>https://www.buzhidao.cc/2022/06/12/%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%98%E6%98%AF%E4%B8%8D%E9%9A%94%E7%A6%BB%E7%9A%84%EF%BC%9F/</id>
    <published>2022-06-12T03:04:00.000Z</published>
    <updated>2025-06-12T02:00:43.934Z</updated>
    
    <content type="html"><![CDATA[<p><code>begin/start transaction</code>命令并不是一个事务的起点，在执行到它们之后的第一个操作InnoDB表的语句，事务才真正启动。使用<code>start transation with consistent snapshot </code>这个命令可以马上启动一个事务。</p><p><strong>在MySQL中有两个视图的概念：</strong></p><ul><li><p>一个是view。它是一个用于查询语句定义的虚拟表，它的语法是：<code>create view ...</code>。</p></li><li><p>另一个是InnoDB 在实现MVCC时用到的一致性<strong>读视图</strong>，即 consistent read view，用于支持RC（Read Commit 读提交）和RR（Repeatable 可重复读）隔离级别实现的。</p></li></ul><h2 id="“快照”在-MVCC-里是怎么工作的？">“快照”在 MVCC 里是怎么工作的？</h2><p>在可重复读隔离级别下，事务在启动的时候就“拍个快照”，这个快照时基于整库的。</p><blockquote><p>如果库有100G，那么启动一个事务就需要拷贝100G数据，这样实现是不现实的。</p></blockquote><h3 id="快照是怎么实现的？">快照是怎么实现的？</h3><p>InnoDB 里面每个事务都有一个唯一的事务ID，叫做transaction id，它是在事务开始的时候向InnoDB 的事务系统申请的，<strong>是按照顺序严格递增的。</strong></p><p>而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p><p>也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。</p><p>如图下所示，就是一个记录被多个事务连续更新后的状态。<br><img src="http://qiniu.deveye.cn/blog/img/20220615111955.png" alt=""></p><p>图中的三个虚线箭头，就是undo log；而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。</p><p><strong>事务启动的时候，以启动的时刻为准，如果一个数据版本低于在事务启动之前生成的，那就可见，如果在启动之后才生成的，那就不可见。</strong></p><p>在实现上，InnoDB为每个事务构造了一个数据，用来保存这个事务的启动瞬间，当前正在“活跃”的所有事务ID，“活跃”指的是，启动了但还没提交。</p><p>数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。</p><p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</p><p><img src="http://qiniu.deveye.cn/blog/img/20220615113104.png" alt=""></p><p>这样，对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：</p><ol><li><p>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</p></li><li><p>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</p></li><li><p>如果落在黄色部分，那就包括两种情况<br>a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；<br>b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。</p></li></ol><p>** InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。**</p><h2 id="更新逻辑">更新逻辑</h2><p><strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong></p><p>当前读，<strong>读取的是最新版本</strong>，并且需要先获取对应记录的锁，如以下这些 SQL 类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select ... lock in share mode</span><br><span class="line"></span><br><span class="line">select ... for update</span><br><span class="line"></span><br><span class="line">update 、delete 、insert</span><br></pre></td></tr></table></figure><p>例如，要 update 一条记录，在事务执行过程中，如果不加锁，那么另一个事务可以 delete 这条数据并且能成功 commit ，就会产生冲突了。所以 update 的时候肯定要是当前读，得到最新的信息并且锁定相应的记录。</p><h2 id="事务的可重复读的能力是怎么实现的？">事务的可重复读的能力是怎么实现的？</h2><p>可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p><p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p><ul><li><p>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</p></li><li><p>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;begin/start transaction&lt;/code&gt;命令并不是一个事务的起点，在执行到它们之后的第一个操作InnoDB表的语句，事务才真正启动。使用&lt;code&gt;start transation with consistent snapshot &lt;/cod</summary>
      
    
    
    
    <category term="MySQL实战45讲" scheme="https://www.buzhidao.cc/categories/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/"/>
    
    
    <category term="MySQL" scheme="https://www.buzhidao.cc/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>行锁功过：怎么减少行锁对性能的影响？</title>
    <link href="https://www.buzhidao.cc/2022/06/12/%E8%A1%8C%E9%94%81%E5%8A%9F%E8%BF%87%EF%BC%9A%E6%80%8E%E4%B9%88%E5%87%8F%E5%B0%91%E8%A1%8C%E9%94%81%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D%EF%BC%9F/"/>
    <id>https://www.buzhidao.cc/2022/06/12/%E8%A1%8C%E9%94%81%E5%8A%9F%E8%BF%87%EF%BC%9A%E6%80%8E%E4%B9%88%E5%87%8F%E5%B0%91%E8%A1%8C%E9%94%81%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D%EF%BC%9F/</id>
    <published>2022-06-12T01:39:51.000Z</published>
    <updated>2025-06-12T02:00:43.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从两阶段锁说起">从两阶段锁说起</h2><p><img src="http://qiniu.deveye.cn/blog/img/20220614094047.png" alt=""></p><p>实际上事务B的update语句会被阻塞，直至事务A执行commit之后，事务B才能继续执行。</p><p><strong>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是等到事务结束才释放，这就是两阶段锁协议。</strong></p><blockquote><p>如果你的事务中需要锁多个行，要把最可能造成冲突、最可能影响并发的锁尽量往后放。</p></blockquote><h2 id="死锁和死锁检测">死锁和死锁检测</h2><p>当并发系统出现资源循环依赖，就会导致这几个线程处于无限等待状态，称为<strong>死锁</strong>。</p><p><img src="http://qiniu.deveye.cn/blog/img/20220614095944.png" alt=""></p><p>两种解决死锁的策略：</p><ul><li><p>一种策略是直接进入等待，直至超时。这个超时时间可以通过参数<code>innodb_lock_wait_timeout</code>来设置。</p></li><li><p>另外一种策略是发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数<code>innodb_deadlock_detect</code>设置为on，表示开启这个逻辑。</p></li></ul><blockquote><p>使用<code>show variables like 'innodb_deadlock_detect';</code>可以查看系统参数。</p></blockquote><h2 id="问题">问题</h2><p>如果你要删除一个表里面的前 10000 行数据，有以下三种方法可以做到：</p><ul><li><p>第一种，直接执行 delete from T limit 10000;</p></li><li><p>第二种，在一个连接中循环执行 20 次 delete from T limit 500;</p></li><li><p>第三种，在 20 个连接中同时执行 delete from T limit 500。</p></li></ul><p>一般会选择第二种。</p><p>第一种方式单个语句占用时间长，锁的时间也比较长；而且大事务还会导致主从延迟。</p><p>第三种方式会人为造成锁冲突。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;从两阶段锁说起&quot;&gt;从两阶段锁说起&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.deveye.cn/blog/img/20220614094047.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;实际上事务B的update语句会被阻塞，直至事务A执行com</summary>
      
    
    
    
    <category term="MySQL实战45讲" scheme="https://www.buzhidao.cc/categories/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/"/>
    
    
    <category term="MySQL" scheme="https://www.buzhidao.cc/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出索引（下）</title>
    <link href="https://www.buzhidao.cc/2022/06/08/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>https://www.buzhidao.cc/2022/06/08/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2022-06-08T01:49:05.000Z</published>
    <updated>2025-06-12T02:00:43.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="覆盖索引">覆盖索引</h2><p>如果执行语句如:<code>select ID from T where k between 3 and 5</code>，这是只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表，这种情况我们称为<strong>覆盖索引</strong>。</p><p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p><h2 id="最左前缀原则">最左前缀原则</h2><p><img src="http://qiniu.deveye.cn/blog/img/20220608105848.png" alt=""><br>可以看到，索引是按照索引定义里面出现的字段排序的。</p><p>只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</p><h3 id="在建立联合索引的时候，如何安排索引内的字段顺序">在建立联合索引的时候，如何安排索引内的字段顺序?</h3><p>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</p><h2 id="索引下推">索引下推</h2><p>MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p><p>例如以下查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tuser where name like &#x27;张 %&#x27; and age=10 and ismale=1;</span><br></pre></td></tr></table></figure><center>无索引下推</center><p><img src="http://qiniu.deveye.cn/blog/img/20220608110650.png" alt=""></p><center>有索引下推</center><p><img src="http://qiniu.deveye.cn/blog/img/20220608110743.png" alt=""></p><p>可以明显的看出，有索引下推的情况下减少了回表的次数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;覆盖索引&quot;&gt;覆盖索引&lt;/h2&gt;
&lt;p&gt;如果执行语句如:&lt;code&gt;select ID from T where k between 3 and 5&lt;/code&gt;，这是只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表，这种情况我们</summary>
      
    
    
    
    <category term="MySQL实战45讲" scheme="https://www.buzhidao.cc/categories/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/"/>
    
    
    <category term="MySQL" scheme="https://www.buzhidao.cc/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出索引（上）</title>
    <link href="https://www.buzhidao.cc/2022/06/07/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>https://www.buzhidao.cc/2022/06/07/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2022-06-07T08:04:14.000Z</published>
    <updated>2025-06-12T02:00:43.935Z</updated>
    
    <content type="html"><![CDATA[<p><strong>索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。</strong></p><h2 id="索引常见模型">索引常见模型</h2><h3 id="哈希表">哈希表</h3><p><img src="http://qiniu.deveye.cn/blog/img/20220607160718.png" alt=""></p><p>哈希表是一种以键值对存储的数据结构，只要输入key，就可以根据key找到对应的vaule。不可避免的是会存在hash冲突，处理这种情况方法是拉出一个链表。（类比Java中HashMap结构）。</p><p>优点：</p><ul><li>查找速度快，新增速度也快。</li></ul><p>缺点：</p><ul><li>因为不是有序的，如果需要范围查询，速度是很慢的。</li></ul><p>哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。</p><h3 id="有序数组">有序数组</h3><p><img src="http://qiniu.deveye.cn/blog/img/20220607160727.png" alt=""></p><p>有序数组查询时，可以使用二分法进行搜索，时间复杂度是O(log(N))，并且有序数据还支持范围查询。但是需要插入的时候，就需要进行数据挪动（因为要保证顺序），成本是非常高的。</p><p>因此，<strong>有序数组索引只适用于静态存储引擎</strong>。</p><h3 id="搜索树">搜索树</h3><p><img src="http://qiniu.deveye.cn/blog/img/20220607160741.png" alt=""></p><p>二叉树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -&gt; UserC -&gt; UserF -&gt; User2 这个路径得到。这个时间复杂度是 O(log(N))。</p><p>当然为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 O(log(N))。</p><p>二叉树的主要缺点是：当数据量很大的时候，树高会非常高，假如树高为20。一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询可真够慢的。</p><h2 id="InnoDB-的索引模型">InnoDB 的索引模型</h2><p>在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。<strong>InnoDB使用的是B+树索引模型</strong>，所以数据都是存储在B+树中的。</p><p><strong>每一个索引在InnoDB中对应一颗B+树。</strong></p><p><img src="http://qiniu.deveye.cn/blog/img/20220607162535.png" alt=""></p><p>从上图来看，索引类型分为：主键索引和非主键索引。</p><p><strong>主键索引在InnoDB中也成为聚簇索引（clustered index），非主键索引在InnoDB中成为二级索引（secondary index）。</strong></p><h3 id="基于主键索引和非主键索引搜索的区别：">基于主键索引和非主键索引搜索的区别：</h3><ul><li><p>基于主键索引查询只需要搜索对应的这颗B+树。</p></li><li><p>基于非主键索引首先先查到对应值的ID（假设ID为主键），再到ID索引树中搜索一次，这个过程称为回表。</p></li></ul><h2 id="索引的维护">索引的维护</h2><h3 id="页分裂">页分裂</h3><p>B+ 树为了维护索引的有序性，在插入新值的时候需要做必要的维护，如果插入的数据需要在页的中间，那么就需要进行数据的挪动，空出位置，如果插入的页刚好满了，就会触发<strong>页分裂</strong>，页分裂除了会影响性能，而且会使整体空间利用率降低50%（因为之前一个页，分裂成了两个）。</p><p>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p><p>基于业务字段做主键，往往不能保证插入的有序性，更容易造成页分裂，基于自增ID做主键，每插入一条记录都是追加操作，一般不会触发叶子结点分裂。由于每个非主键索引叶子结点都是主键的值，如果用整型做主键，只需要4个字节，如果是长整型，则是8个字节。</p><p><strong>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;索引常见模型&quot;&gt;索引常见模型&lt;/h2&gt;
&lt;h3 id=&quot;哈希表&quot;&gt;哈希表&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.deveye.cn</summary>
      
    
    
    
    <category term="MySQL实战45讲" scheme="https://www.buzhidao.cc/categories/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/"/>
    
    
    <category term="MySQL" scheme="https://www.buzhidao.cc/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>事务隔离：为什么你改了我还看不见？</title>
    <link href="https://www.buzhidao.cc/2022/06/07/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E6%88%91%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81/"/>
    <id>https://www.buzhidao.cc/2022/06/07/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E6%88%91%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81/</id>
    <published>2022-06-07T02:31:39.000Z</published>
    <updated>2025-06-12T02:00:43.935Z</updated>
    
    <content type="html"><![CDATA[<p><strong>ACID (Atomicity、Consistency、Isolation、Durability)即原子性、一致性、隔离性、持久性。</strong></p><p>当数据库上有多个事务同时执行的时候，就可能会出现脏读（dirty read）、不可重复读（nonrepeatable read）、幻读（phantom read）的问题。</p><h3 id="隔离级别">隔离级别</h3><p>SQL标准的隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复度（repeatable read）和串行化（serializable）。</p><ul><li><p>读未提交：一个事务还没有提交时，它做的变更就能被别的事务看到。</p></li><li><p>读提交：一个事务提交之后，它做的变更才会被其他事务看到。</p></li><li><p>可重复读：一个事务执行过程中看到的数据，总是跟这个事务启动的时候看到的数据一致。当然在可重复读的隔离级别下，未提交的变更对其他事务也是不可见的。</p></li><li><p>串行化：对同一条记录“写”会加“写锁”，“读”会加“读锁”。当出现读写冲突的时候，后访问的事务必须等待前一个事务执行完成，才能继续执行。</p></li></ul><h3 id="事务隔离的实现">事务隔离的实现</h3><p><strong>数据库隔离的实现上会创建一个视图，访问的时候以视图的逻辑结果为准。</strong></p><p><strong>“可重复读”<strong>隔离级别下，这个视图是在</strong>事务启动时创建的</strong>，整个事务存在期间都会用这个视图。</p><p><strong>“读提交”<strong>隔离级别下，这个视图是在每个SQL语句</strong>开始执行的时候创建的</strong>。</p><p>**“读未提交”**隔离级别下直接返回记录上的最新值，<strong>没有视图的概念</strong>。</p><p><strong>“串行化”<strong>的隔离级别下直接使用</strong>加锁的方式避免并行访问</strong>。</p><p>在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p><p>假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。<br><img src="http://qiniu.deveye.cn/blog/img/20220607152436.png" alt=""></p><p>当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。</p><p>同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。</p><p><strong>回滚日志系统会判断，当系统中没有比这个回滚日志更早的read-view的时候，日志会被删除。</strong></p><h3 id="建议不要使用长事务">建议不要使用长事务</h3><p>长事务意味着系统里面会存在很老的事务视图，由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p><p>长事务还会占用锁资源，也可能拖垮整个库。</p><p>通过以下语句可以查询持续时间超过60s的事务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="事务的启动方式">事务的启动方式</h3><ol><li><p>显式启动，<code>begin或start transaction</code>。配套的提交语句是<code>commit</code>，回滚语句是<code>commit</code>。</p></li><li><p><code>set autocommit=0</code>，这个命令会将这个线程自动提交关闭。意味着如果你只执行select语句，这个事务就启动了，而且不会自动提交。这个事务持续存在直到你主动执行commit或rollback语句，或者断开连接。</p></li></ol><p><strong>建议使用<code>set autocommit=1</code>，通过显式语句的方式启动事务。</strong></p><p>在 autocommit 为 1 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;ACID (Atomicity、Consistency、Isolation、Durability)即原子性、一致性、隔离性、持久性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当数据库上有多个事务同时执行的时候，就可能会出现脏读（dirty read）、不可重复读（n</summary>
      
    
    
    
    <category term="MySQL实战45讲" scheme="https://www.buzhidao.cc/categories/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/"/>
    
    
    <category term="MySQL" scheme="https://www.buzhidao.cc/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>日志系统：一条SQL更新语句是如何执行的?</title>
    <link href="https://www.buzhidao.cc/2022/06/06/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E4%B9%8B%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
    <id>https://www.buzhidao.cc/2022/06/06/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E4%B9%8B%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</id>
    <published>2022-06-06T01:41:17.000Z</published>
    <updated>2025-06-12T02:00:43.935Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redo-log（重做日志）">redo log（重做日志）</h3><p>InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。<br><img src="http://qiniu.deveye.cn/blog/img/20220606110553.png" alt=""></p><p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。</p><h3 id="binlog（归档日志）">binlog（归档日志）</h3><p>binlog没有crash-safe能力，只能用于归档。</p><p>这两种日志的不同点：</p><ul><li><p>redo log是InnoDB引擎特有的，binlog是MySQL的server层实现的，所有引擎都可以使用。</p></li><li><p><strong>redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑。</strong></p></li><li><p>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p></li></ul><h3 id="两阶段提交">两阶段提交</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure><p>执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程:</p><ol><li><p>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</p></li><li><p>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</p></li><li><p>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</p></li><li><p>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</p></li><li><p>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</p></li></ol><p>流程图如下所示：<br><img src="http://qiniu.deveye.cn/blog/img/20220606112558.png" alt=""></p><h3 id="如何让数据库恢复到半个月任意一秒？">如何让数据库恢复到半个月任意一秒？</h3><ul><li>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；</li><li>然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。</li></ul><h3 id="总结">总结</h3><p>建议<code>innodb_flush_log_at_trx_commit</code> 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘，这样可以保证 MySQL 异常重启之后数据不丢失。</p><p>建议<code>sync_binlog </code>这个参数设置成 1 ，表示每次事务的 binlog 都持久化到磁盘，这样可以保证 MySQL 异常重启之后 binlog 不丢失。</p><iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;width:715px; height:245px;" src="https://www.processon.com/embed/629f14fd07912907215003f8"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;redo-log（重做日志）&quot;&gt;redo log（重做日志）&lt;/h3&gt;
&lt;p&gt;InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如</summary>
      
    
    
    
    <category term="MySQL实战45讲" scheme="https://www.buzhidao.cc/categories/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/"/>
    
    
    <category term="MySQL" scheme="https://www.buzhidao.cc/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>基础架构：一条SQL语句是如何执行的?</title>
    <link href="https://www.buzhidao.cc/2022/06/05/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
    <id>https://www.buzhidao.cc/2022/06/05/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</id>
    <published>2022-06-05T13:26:33.000Z</published>
    <updated>2025-06-12T02:00:43.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一条SQL语句是如何执行的">一条SQL语句是如何执行的?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10；</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.deveye.cn/blog/img/20220605212825.png" alt=""></p><p><strong>MySQL 分为Server层和存储引擎两部分。</strong></p><p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等。涵盖MySQL的大多数核心服务功能，以及所有内置函数（如日期、时间、数字和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><p>存储引擎是插件式的，支持InnoDB、MyISAM、Memory等。从MySQL5.5.5版本以后默认存储引擎为InnoDB。</p><h3 id="连接器">连接器</h3><p>连接器主要负责客户端和MySQL服务端进行连接的。可以通过<code>show processlist</code>查看连接信息，客户端和服务端默认连接超时为8小时，可以通过过<code>wait_timeout</code>参数配置。</p><p>长连接使用一段时间后会导致MySQL内存长得很快，主要是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面。这些资源会在连接重新断开的时候才释放。<br>解决方案如下:</p><ul><li><p>定期断开长连接，使用一段时间，或者程序里面判断执行过一个占用内存大的查询后，断开连接，之后要查询再重连。</p></li><li><p>MySQL5.7以后，可以在每次执行一个比较大的操作后，通过执行<code>mysql_reset_connection</code>来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p></li></ul><h3 id="查询缓存">查询缓存</h3><p>之前执行的查询结果可能会以key-value对的形式缓存在内存中，如果查询能够直接在缓存中找到key，那么会直接把value返回给客户端。</p><p>*** 大多数情况下不建议使用查询缓存。***</p><p>如果表中的数据修改的比较频繁，查询缓存的命中率就会非常的低。MySQL提供了以下方式使用查询缓存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select SQL_CACHE * from T where ID=10；</span><br></pre></td></tr></table></figure><p><em><strong>注意： MySQL8.0版本直接将查询缓存的整块功能删掉了。</strong></em></p><h3 id="分析器">分析器</h3><p>分析器主要是分析语法是否正确，如果不正确就会收到“You have an error in your SQL syntax”的错误提醒,一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。如果查询语句中包含表中不存在的字段，也是在这一步分析。</p><h3 id="优化器">优化器</h3><p>优化器的作用主要是决定使用那个索引，或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p><h3 id="执行器">执行器</h3><p>开始执行的时候，要先判断你对这个表有没有执行的查询权限，如果没有，就会返回没有权限的错误。使用慢SQL查询日志中看到<code>rows_examined</code>字段，表示执行过程中扫描了多少行，但有些情况下执行器调用一次，在引擎内部则扫描多行，因此<strong>引擎扫描行数跟rows_examined并不是完全相同</strong>。</p><iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;width:715.781px; height:245px;" src="https://www.processon.com/embed/629cb777e401fd1c3857b913"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一条SQL语句是如何执行的&quot;&gt;一条SQL语句是如何执行的?&lt;/h2&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span</summary>
      
    
    
    
    <category term="MySQL实战45讲" scheme="https://www.buzhidao.cc/categories/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/"/>
    
    
    <category term="MySQL" scheme="https://www.buzhidao.cc/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>数据复制</title>
    <link href="https://www.buzhidao.cc/2022/05/31/%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/"/>
    <id>https://www.buzhidao.cc/2022/05/31/%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/</id>
    <published>2022-05-31T12:36:08.000Z</published>
    <updated>2025-06-12T02:00:43.935Z</updated>
    
    <content type="html"><![CDATA[<p>数据复制方案，人们通常希望达到以下几个目的：</p><ul><li>使数据在地理位置上更接近用户，从而降低访问延迟。</li><li>当部分组件出现故障，系统依然可以继续工作，从而提升可用性。</li><li>扩展至多台机器以同时提供数据访问服务，从而提高吞吐量。</li></ul><p>三种比较流行的复制数据变化的方法：</p><ul><li>主从复制</li><li>多主节点复制</li><li>无主节点复制</li></ul><p>复制技术存在很多折中的方案，例如：同步复制和异步复制，一般情况数据库会采用配置的形式来处理这些策略。</p><h3 id="主节点与从节点">主节点与从节点</h3><p>主从复制的工作原理如下：</p><ol><li>指定一个副本为主节点，当客户写数据库时，只能通过主节点进行写入。</li><li>其他副本作为从副本，主副本将数据写入本地存储后，将数据更改作为复制日志或更改流发送到从副本。每个副本获取到更改数据后将其应用到本地，并且严格保持与主副本相同的写入顺序。</li><li>客户端读取数据时从主副本或者从副本进行读取，从客户端的角度看，从副本都是只读的。</li></ol><h3 id="同步复制与异步复制">同步复制与异步复制</h3><p>同步复制是需要等从节点确认完成了写入之后，才会向用户报告完成。并将最新的写入对其他客户端可见。异步复制是主节点发送完消息之后立即返回，不需要等待从节点完成确认。</p><h4 id="同步复制的优点">同步复制的优点</h4><p>一旦向用户确认，从节点可以明确保证完成了与主节点的更新同步，数据已处于最新版本。万一主节点发生故障，总是可以在从节点继续访问最新数据。</p><h4 id="同步复制的缺点">同步复制的缺点</h4><p>如果同步的从节点无法完成确认（例如由于从节点发送崩溃、网络故障或其他原因），写入就不能视为成功。主节点会阻塞其后面所有的写操作，直到同步副本确认完成。</p><blockquote><p>把所有从节点都设置为同步复制有些不切实际，实践中，可以将某一个节点设置为同步复制，其他节点设置为异步复制。万一同步复制的节点变得不可用或者性能下降，则将另外一个节点从异步模式提升为同步模式，这样可以保证至少有两个节点拥有最新的数据副本。这种配置有时称为<strong>半同步</strong>。</p></blockquote><h4 id="异步复制的优点">异步复制的优点</h4><p>不管从节点的数据多么滞后，主节点总是可以继续响应客户端的写请求，系统的吞吐性能更好。</p><h4 id="异步复制的缺点">异步复制的缺点</h4><p>如果主节点发生故障并且不可恢复，则所有尚未复制到从节点的数据将会丢失，这就意味着向客户端确认了写请求，但是却无法保证数据的持久化。</p><h3 id="配置新的从节点">配置新的从节点</h3><p>如何考虑添加新的从节点，怎么保证主从数据一致性呢？</p><ol><li>在某个时间节点对主节点的数据副本生成一个一致性快照。</li><li>将快照拷贝到新的从节点。</li><li>从节点连接到主节点并请求快照点之后所发生的数据更改日志。因为在第一步创建快照时，快照与系统复制日志的某个确定的位置相关联。</li><li>获得日志之后，从节点应用这些快照点之后的所有数据变更，这个过程称之为<strong>追赶</strong>。接下来，他可以继续处理主节点上的新的数据变化。并重复1~4步骤。</li></ol><h3 id="从节点失效：追赶式恢复">从节点失效：追赶式恢复</h3><p>从节点如果发生了崩溃或者网络闪断，则根据最后一笔事务的处理日志，从主节点拉取之后的所有数据的变更，收到所有数据的变更后，将其应用到本地用于追赶主节点，之后就和正常情况一样持续接收来自主节点数据流的变化。</p><h3 id="主节点失效：节点切换">主节点失效：节点切换</h3><ol><li>确定主节点失效。大部分系统都采用了基于超时的机制判断节点是否失效，节点间频繁地互相发送心跳存活信息，如果某一个节点在一段时间内（例如30s）没有响应，则认为该节点发生了实效。</li><li>选举新的主节点。可以通过选举的方式来选举主节点，候选节点最好与主节点的数据差异最小，这样可以最小化数据丢失的风险。</li><li>重新配置系统使新的主节点生效。如果原主节点重新上线后，可能仍然认为自己是主节点，这是系统要确保原主节点降级为从节点，并认可新的主节点。</li></ol><h4 id="以上切换过程可能会发生很多变数">以上切换过程可能会发生很多变数</h4><ul><li><p>如果使用了异步复制，且失效之前，新的主节点并未收到原主节点的所有数据；在选举之后，原主节点很快又重新上线加入到集群，这是可能原主节点并未意识到角色的变化，还会尝试同步其他从节点，但其中的一个现在已经接管成为现任主节点。<strong>常见的解决方案是：原主节点上未完成复制的写请求就此丢弃，但这可能会违背数据更新持久化的承诺。</strong></p></li><li><p>如果数据库依赖于外部系统（例如Redis）一起协同使用，丢弃数据的方案就特别危险。例如，在GithHub的一次事故中，某个数据并完全的MySQL从节点提升为主节点，数据库使用了基于自增计数器将主键分配给新创建的行，但是因为新的主节点计数器落后于原主节点（即二者并非完全同步），它重新使用了已被原主节点分配出去的某些主键，而恰好这些主键已被外部Redis所引用，结果出现MySQL和Redis之间的不一致，最后导致了某些私有数据被错误的泄露给了其它用户。</p></li><li><p>某些情况下，可能会发生两个节点同时认为自己是主节点，这种情况下被称为<strong>脑裂</strong>，它非常危险：<strong>两个主节点都可能接收写请求，并且没有很好解决冲突的办法，最后数据可能会丢失或者破坏，一种安全应急方案会强制关闭其中的一个节点。</strong></p></li><li><p>如何设置合适的超时来检查主节点失效？主节点失效后，超时时间设置的越长，也就意味着数据恢复的时间越长。如果设置的太短，可能会导致很多不必要的节点切换。例如：突然的负载峰值会导致节点的响应时间变长甚至超时，或者由于网络故障导致延迟增加。如果系统本身已经处于高负载或网络严重拥塞的情况下，不必要的切换只会导致系统的情况变得更糟。</p></li></ul><h2 id="复制日志的实现">复制日志的实现</h2><h4 id="基于语句的复制">基于语句的复制</h4><p>一些不适用的场景：</p><ul><li><p>任何调用非确定性的语句，如<code>NOW()</code>获取当前时间，或<code>RAND()</code>获取一个随机数等，可能会在不同副本产生不同的值。</p></li><li><p>如果语句中使用自增列，或者依赖数据库的现有数据（例如：UPDATE … WHERE … &lt;某些条件&gt;），则所有副本必须按照相同的顺序执行，否则可能会带来不同的结果。</p></li><li><p>有副作用的语句（例如：触发器、存储过程、用户自定义的函数等），可能会在每个副本产生不同的副作用。</p></li></ul><blockquote><p>可能解决的方案是将不确定的函数替换成确定的结果，不过这种方式仍有许多地方需要考虑。</p></blockquote><h4 id="基于预写日志（WAL）传输">基于预写日志（WAL）传输</h4><ul><li><p>对于日志结构的存储引擎（例如：SSTables和LSM-trees），日志是主要的存储方式。日志段在后台压缩并支持垃圾回收。</p></li><li><p>对于采用覆盖写磁盘的Btree结构，每次修改会预先写入日志，如果系统崩溃，通过索引更新的方式迅速恢复到此前一直状态。</p></li></ul><p>缺点：</p><p>WAL包含了哪些磁盘块的哪些字节发生了改变，诸如此类细节，这使得复制方案和存储引擎紧密耦合。如果数据库的存储格式从一个版本改为另一个版本，那么系统通常无法支持主从节点上运行不同版本的软件。</p><h4 id="基于行的逻辑日志复制">基于行的逻辑日志复制</h4><p>关系数据库的逻辑日志通常是指一些列记录数据行级别的写请求：</p><ul><li><p>对行的插入，日志包含所有相关列的新值。</p></li><li><p>对于行的删除，日志有足够的的信息来唯一标识已删除的行。</p></li><li><p>对于行的更新，日志包含足够的信息来唯一标识更新的行，以及所有列的新值。</p></li></ul><blockquote><p>MySQL的二进制日志binlog（当配置基于行的复制时）使用该方式。</p></blockquote><h4 id="基于触发器的复制">基于触发器的复制</h4><p>基于触发器复制支持更高的灵活性。例如将一种数据库的数据复制到另外一种数据库。触发器支持注册自己的应用层代码，使数据库发生数据更改时自动执行自定义代码。 基于触发器的复制通常比其他方式复制开销更高，也比数据库内置复制更容易出错或者暴露一些限制。</p><h2 id="复制滞后的问题">复制滞后的问题</h2><p>由于并非所有写入都反映到副本上，如果同时对主节点和从节点发起相同的查询，可能会得到不同的接口，这种不一致的状态只是暂时的，可能经过一段时间后，从节点最终会赶上主节点并与主节点保持一致。<strong>这种效应也被称为最终一致性。</strong></p><h3 id="读自己的写">读自己的写</h3><p>读自己的写也被称为<strong>读写一致性</strong>。实现读写一致性有多重可行方案：</p><ul><li><p>总是从主节点读取当前用户自己的数据，而从从节点读取其他用户的数据。</p></li><li><p>跟踪数据最近更新时间，如果数据更新后一分钟内总是从主节点读取数据，并监控从节点复制之后的程度，避免从那些滞后时间超过一分钟的从节点读取。</p></li><li><p>客户端记住最近更新时的时间戳，并附带到请求中，根据此信息，系统可以保证对该用户提供读服务时都应该至少包含了该时间戳的更新。如果不够新，则交给其他副本进行处理，要么等待直到副本接收到了最近的更新。</p></li><li><p>如果副本分布在多数据中心，必须先把请求路由到主节点所在的数据中心。</p></li></ul><h3 id="单调读">单调读</h3><p>主要是解决用户看到了最新内容之后又读到了过期的内容，好像时间被回拨，此时需要单调读一致性。（出现这种情况主要是因为主从节点数据不一致或同步滞后导致的）</p><p>解决方案：确保每个用户总是从固定的同一副本执行读取。（例如：基于用户Id进行哈希的方式选择副本，而不是随机选择）</p><h3 id="前缀一致性">前缀一致性</h3><p>在许多分布式数据库中，不同分区独立运行，因此不存在写入顺序。这就导致当用户从数据库中读取数据时，可能会看到数据库的某部分新值和另一部分旧值。</p><p><strong>一个解决方案是确保任何具有因果顺序关系的写入都交给一个分区来完成，但这种方案真是实现效率会大打折扣。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数据复制方案，人们通常希望达到以下几个目的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使数据在地理位置上更接近用户，从而降低访问延迟。&lt;/li&gt;
&lt;li&gt;当部分组件出现故障，系统依然可以继续工作，从而提升可用性。&lt;/li&gt;
&lt;li&gt;扩展至多台机器以同时提供数据访问服务，从而提高吞吐量。&lt;</summary>
      
    
    
    
    <category term="ddia" scheme="https://www.buzhidao.cc/categories/ddia/"/>
    
    
    <category term="分布式" scheme="https://www.buzhidao.cc/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>程序员的测试课</title>
    <link href="https://www.buzhidao.cc/2022/05/30/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%8B%E8%AF%95%E8%AF%BE/"/>
    <id>https://www.buzhidao.cc/2022/05/30/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%8B%E8%AF%95%E8%AF%BE/</id>
    <published>2022-05-30T12:27:05.000Z</published>
    <updated>2025-06-30T05:56:01.527Z</updated>
    
    <content type="html"><![CDATA[<h3 id="时代在要求我们写测试">时代在要求我们写测试</h3><p>因为软件变得越来越复杂，测试可以让我们在复杂的软件开发中稳步前行。另一方面软件测试可以让我们在长期的过程中不断回归，让每一步走的更稳。</p><p>程序员圈子流传着一个关于测试的段子：** 每个程序员在修改代码时都希望有测试，而在写代码时，都不想写测试。**</p><h3 id="大部分程序员都不会写测试">大部分程序员都不会写测试</h3><p>很多程序员反对写测试，本质上的原因是因为他们不会写测试。</p><h3 id="你的代码质量真的高吗？">你的代码质量真的高吗？</h3><ul><li>经过测试的代码，质量会更高；</li><li>要想写好测试，代码本身质量也要高。</li></ul><p><strong>如果你连测试都做不好，你对自己代码的信心从何而来呢？</strong></p><h3 id="学习写测试">学习写测试</h3><p><strong>最好的办法就是跟着会写测试的人一起写一段时间</strong></p><p>思考：可以查阅优秀的开源代码是如何写测试的。</p><hr><h3 id="ToDo项目的一些基本准备工作">ToDo项目的一些基本准备工作</h3><ul><li>一个项目的自动化；</li><li>对需求进行简单设计。</li></ul><p>为什么需要自动化呢？简单来说是为了防止一些低级错误。</p><p><strong>把核心的业务部分和命令行呈现的部分分开。</strong></p><h3 id="任务分解">任务分解</h3><p>从离我们需求最近的入口开始。</p><p><strong>要想测试一个函数，一个函数最好是可测的。什么是可测的？就是通过函数的接口设计，我们给出特定的输入，它能给我们相应的输出。所以，一个函数最好是有返回值的。</strong></p><p><a href="https://time.geekbang.org/column/article/84374">Fail Fast 原则</a><br><strong>一条设计规范：对于输入参数的检测，由入口部分代码进行处理。</strong><br><strong>一条设计规范：Repository 的问题以运行时异常的形式抛出，业务层不需要做任何处理。</strong></p><p>项目刚开始时，我们要准备哪些内容：</p><ul><li>项目的自动化；</li><li>针对需求进行初步的设计。</li></ul><p>着手编写代码时，我们要怎么做呢？</p><ul><li>对要实现的需求进行任务分解；</li><li>在一个具体的需求任务中，我们可以从需求入口开始入手；</li><li>设计一个可测试的函数；</li><li>针对具体的函数，考虑测试场景；</li><li>针对具体的测试场景，将场景具象化成测试用例。</li></ul><p>在梳理的过程中，我们还会针对一些统一的情况作出一些约定，成为项目整体的设计规范，比如，在这里我们约定：</p><ul><li>对于输入参数的检测，由入口部分代码进行处理；</li><li>Repository 的问题以运行时异常的形式抛出，业务层不需要做任何处理。</li></ul><p>在编码的过程中，我们也看到了：</p><ul><li>根据不断增加的需求，逐渐改动我们的设计，这就是演化式设计的基本做法；</li><li>我们对待测试也像对待代码一样，会消除代码中存在的一些坏味道。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;时代在要求我们写测试&quot;&gt;时代在要求我们写测试&lt;/h3&gt;
&lt;p&gt;因为软件变得越来越复杂，测试可以让我们在复杂的软件开发中稳步前行。另一方面软件测试可以让我们在长期的过程中不断回归，让每一步走的更稳。&lt;/p&gt;
&lt;p&gt;程序员圈子流传着一个关于测试的段子：** 每个程序员</summary>
      
    
    
    
    <category term="程序员的测试课" scheme="https://www.buzhidao.cc/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%8B%E8%AF%95%E8%AF%BE/"/>
    
    
    <category term="测试" scheme="https://www.buzhidao.cc/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>我每天使用的11个Git Commands</title>
    <link href="https://www.buzhidao.cc/2022/04/12/%E6%88%91%E6%AF%8F%E5%A4%A9%E4%BD%BF%E7%94%A8%E7%9A%8411%E4%B8%AAGitCommands/"/>
    <id>https://www.buzhidao.cc/2022/04/12/%E6%88%91%E6%AF%8F%E5%A4%A9%E4%BD%BF%E7%94%A8%E7%9A%8411%E4%B8%AAGitCommands/</id>
    <published>2022-04-12T10:21:19.000Z</published>
    <updated>2025-06-12T02:00:43.935Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是为我的年轻人（或任何新手）准备的，他们可以有效地使用git命令行，并简要介绍了我如何使用这些命令。<br><a href="https://medium.com/@mmpatil34/11-git-commands-i-use-daily-9bbd7590c8eb">https://medium.com/@mmpatil34/11-git-commands-i-use-daily-9bbd7590c8eb</a></p></blockquote><h3 id="1-git-fetch-origin">1. git fetch origin</h3><p>从特定的仓库拉取所有的branchs/tags, 这里的仓库是“origin”, 我每天从这个命令开始, 它可以让本地和远程仓库状态保持一致.</p><h3 id="2-git-status">2. git status</h3><p>显示当前分支自上次提交到现在的文件改动列表,在切换分支、创建新分支、进行新更改或拉取更改之前, 此命令可以检查是否有文件需要被stash.</p><h3 id="3-git-checkout">3. git checkout</h3><p><code>git checkout -b &lt;new branch name&gt; origin/&lt;source branch name&gt;</code><br>从特定源分支创建一个新分支,这块的“origin”代表默认仓库.<br><code>git checkout — — &lt;name of the file&gt;</code><br>当本地有文件变动时,可以使用这个命令丢弃当前改变,恢复文件到之前状态.<br><code>git checkout &lt;branch name&gt;</code><br>切换本地到指定分支.</p><h3 id="4-git-pull-origin-branch-name">4. git pull origin <branch name></h3><p>将更改从远程分支拉到本地分支，并在更改兼容的情况下调用<code>git merge</code>。<br><code>git pull 和 git fetch</code>的不同之处是:<code> git pull = git fetch + git merge</code></p><h3 id="5-git-add-name-of-the-file">5. git add <name of the file></h3><p>文件修改完成后,就可以使用<code>git add</code>命令将文件添加到特定提交中,使用<code>git status</code>命令可以很方便的获取到要添加指定提交的文件名.</p><h3 id="6-git-commit">6. git commit</h3><p><code>git commit -m &quot;&lt;提交内容的描述&gt;&quot;</code><br>提交本地改变,并指定和提交内容相关的描述.</p><h3 id="7-git-push-origin-branch-name">7. git push origin <branch name></h3><p>将本地提交推送到远程存储库,这里的仓库是“origin”.</p><h3 id="8-git-cherry-pick">8. git cherry-pick</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a - b - c - d   Master</span><br><span class="line">         \</span><br><span class="line">           e - f - g Feature</span><br></pre></td></tr></table></figure><p>现在将提交f应用到master分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 切换到 master 分支</span><br><span class="line">$ git checkout master</span><br><span class="line"> </span><br><span class="line"># Cherry pick 操作</span><br><span class="line">$ git cherry-pick f</span><br></pre></td></tr></table></figure><p>上面的操作完成以后，代码库就变成了下面的样子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a - b - c - d - f   Master</span><br><span class="line">        \</span><br><span class="line">          e - f - g Feature</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick -m 1 &lt;commit_id&gt;</span><br></pre></td></tr></table></figure><p>如果原始提交是一个合并节点，来自于两个分支的合并，那么 Cherry pick 默认将失败，因为它不知道应该采用哪个分支的代码变动。</p><p><code>-m</code>配置项告诉 Git，应该采用哪个分支的变动。它的参数parent-number是一个从1开始的整数，代表原始提交的父分支编号。</p><p>上面命令表示，Cherry pick 采用提交commitHash来自编号1的父分支的变动。<br>一般来说，1号父分支是接受变动的分支（the branch being merged into），2号父分支是作为变动来源的分支（the branch being merged from）。</p><h3 id="9-git-revert-commit-id">9. git revert <commit id></h3><p>引入一个新的提交来撤回已经push的提交.</p><h3 id="10-git-reset-—-soft-HEAD-1">10. git reset — soft HEAD~1</h3><p>撤消一次本地提交而不会丢失文件中的变更.</p><h3 id="11-git-reset-—-hard-HEAD-1">11. git reset — hard HEAD~1</h3><p>撤销一次本地提交并且丢弃文件中的变更.<br>希望对你有帮助. 感谢阅读😁</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是为我的年轻人（或任何新手）准备的，他们可以有效地使用git命令行，并简要介绍了我如何使用这些命令。&lt;br&gt;
&lt;a href=&quot;https://medium.com/@mmpatil34/11-git-commands-i-use-daily-</summary>
      
    
    
    
    <category term="Git" scheme="https://www.buzhidao.cc/categories/Git/"/>
    
    
    <category term="Git" scheme="https://www.buzhidao.cc/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Netty</title>
    <link href="https://www.buzhidao.cc/2022/04/12/Netty/"/>
    <id>https://www.buzhidao.cc/2022/04/12/Netty/</id>
    <published>2022-04-12T02:09:42.000Z</published>
    <updated>2025-06-12T02:00:43.933Z</updated>
    
    <content type="html"><![CDATA[<iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;width:715px; height:245px;" src="https://www.processon.com/embed/629f20a77d9c08075a36bd94"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe id=&quot;embed_dom&quot; name=&quot;embed_dom&quot; frameborder=&quot;0&quot; style=&quot;display:block;width:715px; height:245px;&quot; src=&quot;https://www.processon.com/embe</summary>
      
    
    
    
    <category term="Netty" scheme="https://www.buzhidao.cc/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://www.buzhidao.cc/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>go反向代理quickstart</title>
    <link href="https://www.buzhidao.cc/2022/04/07/golang%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86quickstart/"/>
    <id>https://www.buzhidao.cc/2022/04/07/golang%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86quickstart/</id>
    <published>2022-04-07T06:18:08.000Z</published>
    <updated>2025-06-12T02:00:43.934Z</updated>
    
    <content type="html"><![CDATA[<p>main.go</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;context&quot;</span><br><span class="line">&quot;github.com/gorilla/mux&quot;</span><br><span class="line">&quot;github.com/txn2/txeh&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;net/http/httputil&quot;</span><br><span class="line">&quot;net/url&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;os/signal&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var hostArr = []string&#123;&quot;project-01&quot;, &quot;project-02&quot;&#125;</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">host     = &quot;api-dev.deveye.cn&quot;</span><br><span class="line">proxyUrl = &quot;https://api-dev.deveye.cn/&quot;</span><br><span class="line">address  = &quot;127.0.0.1&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">hosts, err := txeh.NewHostsDefault()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line">hosts.AddHosts(address, hostArr)</span><br><span class="line">log.Println(hosts.Save())</span><br><span class="line">r := mux.NewRouter()</span><br><span class="line">r.Use(LoggingHandler, AuthHandler, RecoverHandler)</span><br><span class="line">r.PathPrefix(&quot;/&quot;).HandlerFunc(ReverseProxy)</span><br><span class="line">srv := &amp;http.Server&#123;</span><br><span class="line">Addr:    &quot;:80&quot;,</span><br><span class="line">Handler: r,</span><br><span class="line">&#125;</span><br><span class="line">go func() &#123;</span><br><span class="line">if err := srv.ListenAndServe(); err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">c := make(chan os.Signal, 1)</span><br><span class="line">signal.Notify(c, os.Interrupt)</span><br><span class="line">&lt;-c</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">defer cancel()</span><br><span class="line">log.Println(srv.Shutdown(ctx))</span><br><span class="line">hosts.RemoveHosts(hostArr)</span><br><span class="line">log.Println(hosts.Save())</span><br><span class="line">log.Println(&quot;shutting down&quot;)</span><br><span class="line">os.Exit(0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func ReverseProxy(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">u, err := url.Parse(proxyUrl)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">proxy := httputil.NewSingleHostReverseProxy(u)</span><br><span class="line">r.Host = host</span><br><span class="line">proxy.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>middleware.go</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;bytes&quot;</span><br><span class="line">&quot;encoding/json&quot;</span><br><span class="line">&quot;errors&quot;</span><br><span class="line">&quot;io/ioutil&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var loginUrl = proxyUrl + &quot;login/sms&quot;</span><br><span class="line"></span><br><span class="line">func LoggingHandler(next http.Handler) http.Handler &#123;</span><br><span class="line">fn := func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">t1 := time.Now()</span><br><span class="line">next.ServeHTTP(w, r)</span><br><span class="line">t2 := time.Now()</span><br><span class="line">log.Printf(&quot;[%s] %q %v&quot;, r.Method, r.URL.String(), t2.Sub(t1))</span><br><span class="line">&#125;</span><br><span class="line">return http.HandlerFunc(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func RecoverHandler(next http.Handler) http.Handler &#123;</span><br><span class="line">fn := func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">defer func() &#123;</span><br><span class="line">if err := recover(); err != nil &#123;</span><br><span class="line">log.Printf(&quot;Recover from panic: %+v&quot;, err)</span><br><span class="line">http.Error(w, http.StatusText(500), 500)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">next.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br><span class="line">return http.HandlerFunc(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func AuthHandler(next http.Handler) http.Handler &#123;</span><br><span class="line">return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">token, err := getAccessToken()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">r.Header.Set(&quot;X-Auth-AppId&quot;, &quot;10003&quot;)</span><br><span class="line">r.Header.Set(&quot;X-Auth-Token&quot;, token)</span><br><span class="line">next.ServeHTTP(w, r)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getAccessToken() (string, error) &#123;</span><br><span class="line">params := map[string]string&#123;</span><br><span class="line">&quot;phone&quot;:      &quot;15555555551&quot;,</span><br><span class="line">&quot;verifyCode&quot;: &quot;888888&quot;,</span><br><span class="line">&quot;codeId&quot;:     &quot;111111&quot;,</span><br><span class="line">&#125;</span><br><span class="line">marshal, _ := json.Marshal(params)</span><br><span class="line">reader := bytes.NewReader(marshal)</span><br><span class="line">request, _ := http.NewRequest(&quot;POST&quot;, loginUrl, reader)</span><br><span class="line">request.Header.Add(&quot;X-Auth-AppId&quot;, &quot;10003&quot;)</span><br><span class="line">request.Header.Set(&quot;content-type&quot;, &quot;application/json&quot;)</span><br><span class="line">client := &amp;http.Client&#123;&#125;</span><br><span class="line">do, err := client.Do(request)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return &quot;&quot;, err</span><br><span class="line">&#125;</span><br><span class="line">b, err := ioutil.ReadAll(do.Body)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return &quot;&quot;, err</span><br><span class="line">&#125;</span><br><span class="line">_ = do.Body.Close()</span><br><span class="line">result := &amp;LoginResult&#123;&#125;</span><br><span class="line">if err := json.Unmarshal(b, result); err != nil &#123;</span><br><span class="line">return &quot;&quot;, err</span><br><span class="line">&#125;</span><br><span class="line">if result.ErrCode != &quot;0&quot; &#123;</span><br><span class="line">return &quot;&quot;, errors.New(result.Message)</span><br><span class="line">&#125;</span><br><span class="line">return result.Data.Token, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type LoginResult struct &#123;</span><br><span class="line">ErrCode string</span><br><span class="line">Message string</span><br><span class="line">Data    struct &#123;</span><br><span class="line">Name  string</span><br><span class="line">Token string</span><br><span class="line">Phone string</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;main.go&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/s</summary>
      
    
    
    
    <category term="go" scheme="https://www.buzhidao.cc/categories/go/"/>
    
    
    <category term="go" scheme="https://www.buzhidao.cc/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus快速入门</title>
    <link href="https://www.buzhidao.cc/2022/02/28/Prometheus%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>https://www.buzhidao.cc/2022/02/28/Prometheus%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</id>
    <published>2022-02-28T12:43:09.000Z</published>
    <updated>2025-06-12T02:00:43.933Z</updated>
    
    <content type="html"><![CDATA[<h1>Prometheus快速入门</h1><h2 id="一、背景">一、背景</h2><p>我们日常开发和运维中，需要监控一些数据，根据这些数据进行分析或者应对策略，例如以下几个维度：</p><table><thead><tr><th style="text-align:left">场景                          </th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left">硬件系统</td><td>温度，硬件故障</td></tr><tr><td style="text-align:left">系统监控</td><td>CPU，内存，磁盘，网卡流量，TCP状态，进程数</td></tr><tr><td style="text-align:left">应用监控</td><td>Nginx，Tomcat，PHP，MySQL，Redis 等</td></tr><tr><td style="text-align:left">日志监控</td><td>系统日志，服务日志，访问日志，错误日志</td></tr><tr><td style="text-align:left">安全监控</td><td>WAF，敏感文件监控</td></tr><tr><td style="text-align:left">API监控</td><td>可用性，接口请求，响应时间</td></tr><tr><td style="text-align:left">业务监控</td><td>例如电商网站，每分钟产生多少订单，注册多少用户，多少活跃用户，推广活动效果</td></tr><tr><td style="text-align:left">流量分析</td><td>根据流量获取用户相关信息，例如用户地理位置，某页面访问状况，页面停留时间等</td></tr></tbody></table><h2 id="二、Prometheus是什么">二、Prometheus是什么?</h2><p><img src="http://qiniu.deveye.cn/blog/img/20220228204837.png" alt=""></p><p><a href="https://github.com/prometheus">Prometheus</a> 是由 SoundCloud 开发的开源监控报警系统和时序列数据库(TSDB)。</p><p>Prometheus由Go语言编写而成，采用Pull方式获取监控信息，并提供了多维度的数据模型和灵活的查询接口。<br>Prometheus不仅可以通过静态文件配置监控对象，还支持自动发现机制，能通过Kubernetes、Consl、DNS等多种方式动态获取监控对象。<br>在数据采集方面，借助Go语言的高并发特性，单机Prometheus可以采取数百个节点的监控数据；在数据存储方面，随着本地时序数据库的不断优化，单机Prometheus每秒可以采集一千万个指标，如果需要存储大量的历史监控数据，则还支持远程存储。</p><h2 id="三、为什么需要Prometheus">三、为什么需要Prometheus?</h2><ul><li>对于运维人员来说，他们需要监控机器的 CPU、内存、硬盘的使用情况，以此来保证运行在机器上的应用的稳定性。</li><li>对于研发人员来说，他们关注某个异常指标的变化情况，从而来保证业务的稳定运行。</li><li>对于产品或运营来说，他们更关心产品层面的事情，例如：某个活动参加人数的增长情况，活动积分的发放情况。</li></ul><p><strong>例如</strong>：运维希望在 CPU 达到 80% 的时候给值班的运维人员发送邮件，产品希望活动积分发放数量超过 10 万的时候发送告警邮件。这些都可以通过 Prometheus 实现。</p><p>对于流量不是很大的系统来说，出现几分钟的故障可能造成不了多少损失。但是对于像淘宝、美团、字节跳动这样的巨无霸来说，<strong>宕机 1 分钟损失的金额可能就是几百万！</strong></p><p>所以弄清楚此时此刻系统的运行是否正常？各项业务指标是否超过阈值？这些问题是每个经验丰富的研发人员所需要关注的事情！</p><p>那么如何监控你的系统？如何得知系统目前是正常还是异常？甚至如何预知未来一段时间系统可能出问题？<strong>Prometheus 正是这么一套数据监控解决方案。它能让你随时掌控系统的运行状态，快速定位出现问题的位置，快速排除故障。</strong></p><p>只要按照 Prometheus 的方式来做，按部就班地学习和部署，我们就可以监控机器的 CPU、内存等资源的使用情况、Java 应用的运行情况以及业务各项指标的实时数据。</p><p>而通过 Prometheus 则可以直接部署使用，并且其与 Grafana 配套使用可以呈现出非常多样化的图表配置。<strong>对于中小规模的团队来说，可以极大地减少成本，加快研发速度。</strong></p><p>而对于个人来讲，<strong>掌握 Prometheus 可以增加你当 leader 的竞争力。</strong> 毕竟如果一个研发对自己的系统运行状况都不了解，那么他怎么做 leader，怎么带领一个团队往前冲呢？</p><h2 id="四、Prometheus-Quickly-Start">四、Prometheus Quickly Start</h2><h3 id="1、实现目标">1、实现目标</h3><p>实现一个Web服务接口请求速率状况的监控功能，当接口请求增长速率超出设定的阈值时，发送钉钉消息通知给研发运维人员。</p><h3 id="2、服务搭建">2、服务搭建</h3><p>这里使用<strong>Docker</strong> 搭建 <strong>prometheus、alertmanager和dingtalk.</strong></p><p>① 创建对应文件目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/prometheus/ &amp;&amp; <span class="built_in">cd</span> ~/prometheus/ &amp;&amp; <span class="built_in">touch</span> prometheus.yml</span><br><span class="line"><span class="built_in">mkdir</span> -p ~/prometheus/groups/nodegroups/ &amp;&amp; <span class="built_in">cd</span> ~/prometheus/groups/nodegroups/ &amp;&amp; <span class="built_in">touch</span> node.json</span><br><span class="line"><span class="built_in">mkdir</span> -p ~/prometheus/rules/ &amp;&amp; <span class="built_in">cd</span> ~/prometheus/rules/ &amp;&amp; <span class="built_in">touch</span> http-rate.rules</span><br><span class="line"><span class="built_in">mkdir</span> -p ~/prometheus/alertmanager &amp;&amp; /prometheus/alertmanager &amp;&amp; <span class="built_in">touch</span> alertmanager.yml</span><br></pre></td></tr></table></figure><p>② 配置对应文件</p><p><strong>prometheus.yml</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval:     15s <span class="comment"># By default, scrape targets every 15 seconds.</span></span><br><span class="line">  <span class="comment"># Attach these labels to any time series or alerts when communicating with</span></span><br><span class="line">  <span class="comment"># external systems (federation, remote storage, Alertmanager).</span></span><br><span class="line">  external_labels:</span><br><span class="line">    monitor: <span class="string">&#x27;codelab-monitor&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A scrape configuration containing exactly one endpoint to scrape:</span></span><br><span class="line"><span class="comment"># Here it&#x27;s Prometheus itself.</span></span><br><span class="line">scrape_configs:</span><br><span class="line">  <span class="comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span></span><br><span class="line">  - job_name: <span class="string">&#x27;prometheus&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Override the global default and scrape targets from this job every 5 seconds.</span></span><br><span class="line">    scrape_interval: 5s</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [<span class="string">&#x27;localhost:9090&#x27;</span>]</span><br><span class="line"></span><br><span class="line">  - job_name: <span class="string">&#x27;prometheus-sample&#x27;</span></span><br><span class="line"><span class="comment"># 可以在不用重启的情况下热加载配置文件</span></span><br><span class="line">    file_sd_configs:</span><br><span class="line">       - files: [<span class="string">&#x27;/usr/local/prometheus/groups/nodegroups/*.json&#x27;</span>]</span><br><span class="line"><span class="comment"># Alertmanager configuration</span></span><br><span class="line">alerting:</span><br><span class="line">  alertmanagers:</span><br><span class="line">  - static_configs:</span><br><span class="line">    - targets:</span><br><span class="line">      - 192.168.220.121:9093</span><br><span class="line">rule_files:</span><br><span class="line">  - <span class="string">&quot;/usr/local/prometheus/rules/*.rules&quot;</span></span><br></pre></td></tr></table></figure><p><strong>node.json</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;targets&quot;</span>: [<span class="string">&quot;192.168.220.121:8080&quot;</span>,<span class="string">&quot;192.168.220.121:8081&quot;</span>],</span><br><span class="line">        <span class="string">&quot;labels&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;instance&quot;</span>: <span class="string">&quot;vm-192.168.220.121&quot;</span>,</span><br><span class="line">            <span class="string">&quot;service&quot;</span>: <span class="string">&quot;node-service&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>http-rate.rules</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">groups</span>:</span><br><span class="line">  - name: http-rate</span><br><span class="line">    rules:</span><br><span class="line">      - alert: http-rate</span><br><span class="line">        <span class="built_in">expr</span>: rate(prometheus_sample_hello_world_count[1m]) &gt; 100</span><br><span class="line">        <span class="keyword">for</span>: 15s</span><br><span class="line">        labels:</span><br><span class="line">          severity: 1</span><br><span class="line">        annotations:</span><br><span class="line">          summary: <span class="string">&quot;&#123;&#123; <span class="variable">$labels</span>.instance &#125;&#125; HTTP 1min请求增长率超过100%&quot;</span></span><br></pre></td></tr></table></figure><p><strong>alertmanager.yml</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局配置项</span></span><br><span class="line">global:</span><br><span class="line">  resolve_timeout: 5m <span class="comment"># 处理超时时间，默认为5min</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义路由树信息</span></span><br><span class="line">route:</span><br><span class="line">  group_by: [alertname]  <span class="comment"># 报警分组依据</span></span><br><span class="line">  receiver: ops_notify   <span class="comment"># 设置默认接收人</span></span><br><span class="line">  group_wait: 30s        <span class="comment"># 最初即第一次等待多久时间发送一组警报的通知</span></span><br><span class="line">  group_interval: 60s    <span class="comment"># 在发送新警报前的等待时间</span></span><br><span class="line">  repeat_interval: 1h    <span class="comment"># 重复发送告警时间。默认1h</span></span><br><span class="line">  routes:</span><br><span class="line"></span><br><span class="line">  - receiver: ops_notify  <span class="comment"># 基础告警通知</span></span><br><span class="line">    group_wait: 10s</span><br><span class="line">    match_re:</span><br><span class="line">      alertname: 实例存活告警|磁盘使用率告警   <span class="comment"># 匹配告警规则中的名称发送</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义基础告警接收者</span></span><br><span class="line">receivers:</span><br><span class="line">- name: ops_notify</span><br><span class="line">  webhook_configs:</span><br><span class="line">  - url: http://192.168.220.121:8060/dingtalk/webhook/send</span><br><span class="line">    send_resolved: <span class="literal">true</span>  <span class="comment"># 警报被解决之后是否通知</span></span><br><span class="line"><span class="comment"># 一个inhibition规则是在与另一组匹配器匹配的警报存在的条件下，使匹配一组匹配器的</span></span><br><span class="line">警报失效的规则。两个警报必须具有一组相同的标签。</span><br><span class="line">inhibit_rules:</span><br><span class="line">  - source_match:</span><br><span class="line">      severity: <span class="string">&#x27;critical&#x27;</span></span><br><span class="line">    target_match:</span><br><span class="line">      severity: <span class="string">&#x27;warning&#x27;</span></span><br><span class="line">    equal: [<span class="string">&#x27;alertname&#x27;</span>, <span class="string">&#x27;dev&#x27;</span>, <span class="string">&#x27;instance&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>config.yml</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">targets:</span><br><span class="line">  webhook:</span><br><span class="line">    url: https://oapi.dingtalk.com/robot/send?access_token=xxx</span><br><span class="line">    <span class="comment"># secret for signature</span></span><br><span class="line">    secret: SECxxx</span><br></pre></td></tr></table></figure><p><strong>docker 创建服务</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker run --name prometheus -d -p 9090:9090 \</span><br><span class="line">        -v ~/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml \</span><br><span class="line">        -v ~/prometheus/groups/:/usr/local/prometheus/groups/ \</span><br><span class="line">        -v ~/prometheus/rules/:/usr/local/prometheus/rules/ \</span><br><span class="line">        prom/prometheus:latest</span><br><span class="line"></span><br><span class="line">docker run --name alertmanager -d -p 9093:9093 \</span><br><span class="line">        -v ~/prometheus/alertmanager/alertmanager.yml:/etc/alertmanager/alertmanager.yml \</span><br><span class="line">        prom/alertmanager:latest</span><br><span class="line"></span><br><span class="line">docker run --name dingtalk -d -p 8060:8060 \</span><br><span class="line">        -v ~/prometheus/dingtalk/config.yml:/etc/prometheus-webhook-dingtalk/config.yml \</span><br><span class="line">        timonwong/prometheus-webhook-dingtalk</span><br></pre></td></tr></table></figure><h3 id="3、客户端代码">3、客户端代码</h3><p>这里使用Go语言编写的一个简易的Web服务，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/prometheus/client_golang/prometheus&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/prometheus/client_golang/prometheus/promhttp&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var port = flag.Int(<span class="string">&quot;p&quot;</span>, 8080, <span class="string">&quot;-port 8080&quot;</span>)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">flag.Parse()</span><br><span class="line">prometheus.Register(httpCount)</span><br><span class="line">http.Handle(<span class="string">&quot;/metrics&quot;</span>, promhttp.Handler())</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, HelloWorld)</span><br><span class="line">log.Fatalln(http.ListenAndServe(fmt.Sprintf(<span class="string">&quot;:%d&quot;</span>, *port), nil))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var httpCount = prometheus.NewCounter(</span><br><span class="line">prometheus.CounterOpts&#123;</span><br><span class="line">Name: <span class="string">&quot;prometheus_sample_hello_world_count&quot;</span>,</span><br><span class="line">Help: <span class="string">&quot;hello world count!&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func HelloWorld(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">httpCount.Inc()</span><br><span class="line">w.Write([]byte(<span class="string">&quot;Hello World!&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们启动两个节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go run main -p 8080</span><br><span class="line">go run main -p 8081</span><br></pre></td></tr></table></figure><h3 id="4、Prometheus-Dashboard">4、Prometheus Dashboard</h3><p>打开仪表盘：<a href="http://localhost:9090/targets">http://localhost:9090/targets</a>，我们可以看到我们的两个节点已经是up状态了。</p><p><img src="http://qiniu.deveye.cn/blog/img/20220228204908.png" alt=""></p><p>下面我们使用<strong>ab</strong> 工具模拟接口访问，使请求速度超过我们设定的阈值，此时alertmanages会给我们钉钉进行通知。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -n 1000  -c 5  http://localhost:8080/hello</span><br></pre></td></tr></table></figure><p>我可以查看Prometheus控制台，查看消息警告发送情况，此时，我们的钉钉已经收到通知警告：</p><p><img src="http://qiniu.deveye.cn/blog/img/20220228204941.png" alt=""></p><p><img src="http://qiniu.deveye.cn/blog/img/20220228205009.png" alt=""></p><h3 id="5、总结">5、总结</h3><p>我们通过一个简单的实验，实现了一个接口请求速率监控的例子，实际业务中我们还可以做更多服务监控的功能。也可以结合Grafana进行Dashbords数据报表展示等功能。同时可以监控服务器、JVM、k8s等等，当服务按照我们设置的规则达到阈值时通知到我们，我们可以在第一时间做应对处理，避免造成不必要的损失。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Prometheus快速入门&lt;/h1&gt;
&lt;h2 id=&quot;一、背景&quot;&gt;一、背景&lt;/h2&gt;
&lt;p&gt;我们日常开发和运维中，需要监控一些数据，根据这些数据进行分析或者应对策略，例如以下几个维度：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-a</summary>
      
    
    
    
    <category term="prometheus" scheme="https://www.buzhidao.cc/categories/prometheus/"/>
    
    
    <category term="prometheus" scheme="https://www.buzhidao.cc/tags/prometheus/"/>
    
  </entry>
  
  <entry>
    <title>心中需破除的三种贼</title>
    <link href="https://www.buzhidao.cc/2022/02/21/%E5%BF%83%E4%B8%AD%E9%9C%80%E7%A0%B4%E9%99%A4%E7%9A%84%E4%B8%89%E7%A7%8D%E8%B4%BC/"/>
    <id>https://www.buzhidao.cc/2022/02/21/%E5%BF%83%E4%B8%AD%E9%9C%80%E7%A0%B4%E9%99%A4%E7%9A%84%E4%B8%89%E7%A7%8D%E8%B4%BC/</id>
    <published>2022-02-21T06:18:00.000Z</published>
    <updated>2025-06-12T02:00:43.935Z</updated>
    
    <content type="html"><![CDATA[<p><strong>坐中静</strong>，破焦虑之贼——可以用冥想打坐等方法让自己回到当下，人之所以会焦虑是基于过去的经验对未来产生的恐惧，能够活在当下的人不会焦虑。把每一天每一刻过好，人生自然就会好。<br><strong>舍中得</strong>，破欲望之贼——人的痛苦多来自于欲望，即为贪婪和占有，也是一种匮乏的表现，如果能够学会舍，则内心越来越丰盛。没钱的时候把勤舍出去即为天道酬勤；有钱的时候把钱舍出去人就来了，是为轻财聚人；有人的时候，把爱舍出去，成功便有了；事业有成的时候，把智慧舍出去，喜悦就来了，这就是德行天下。<br><strong>事上练</strong>，破犹豫之贼——这里讲的大概是王阳明的知行合一。光懂了很多道理是过不好这一生的，唯有践行其中的道理才能真正成事，只要想到就去做，犹豫纠结之贼就能破，达到知行合一的最高境界，则万事可成。</p><blockquote><p>作者：数中有术作者<br>链接：<a href="https://www.zhihu.com/question/448566584/answer/1898949098">https://www.zhihu.com/question/448566584/answer/1898949098</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;坐中静&lt;/strong&gt;，破焦虑之贼——可以用冥想打坐等方法让自己回到当下，人之所以会焦虑是基于过去的经验对未来产生的恐惧，能够活在当下的人不会焦虑。把每一天每一刻过好，人生自然就会好。&lt;br&gt;
&lt;strong&gt;舍中得&lt;/strong&gt;，破欲望之贼——人的痛</summary>
      
    
    
    
    <category term="人生" scheme="https://www.buzhidao.cc/categories/%E4%BA%BA%E7%94%9F/"/>
    
    
    <category term="人生" scheme="https://www.buzhidao.cc/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL常见问题处理</title>
    <link href="https://www.buzhidao.cc/2021/09/26/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"/>
    <id>https://www.buzhidao.cc/2021/09/26/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/</id>
    <published>2021-09-26T05:53:55.000Z</published>
    <updated>2025-06-12T02:00:43.933Z</updated>
    
    <content type="html"><![CDATA[<ul><li>关于MySQL出现<code>lock wait timeout exceeded; try restarting transaction</code> 的解决方案。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.innodb_trx;</span><br><span class="line"></span><br><span class="line">kill $trx_mysql_thread_id;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;关于MySQL出现&lt;code&gt;lock wait timeout exceeded; try restarting transaction&lt;/code&gt; 的解决方案。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;</summary>
      
    
    
    
    <category term="MySQL" scheme="https://www.buzhidao.cc/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://www.buzhidao.cc/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>10x程序员总结</title>
    <link href="https://www.buzhidao.cc/2021/04/13/10x%E7%A8%8B%E5%BA%8F%E5%91%98%E6%80%BB%E7%BB%93/"/>
    <id>https://www.buzhidao.cc/2021/04/13/10x%E7%A8%8B%E5%BA%8F%E5%91%98%E6%80%BB%E7%BB%93/</id>
    <published>2021-04-13T01:19:17.000Z</published>
    <updated>2025-06-12T02:00:43.932Z</updated>
    
    <content type="html"><![CDATA[<h3 id="以终为始">以终为始</h3><p>遇到问题不妨倒着去思考</p><h3 id="任务分解">任务分解</h3><ul><li>埃隆马斯克SpaceX 的计划，本质上就是把一件很困难实现的事情去做任务分解，使每件任务可执行化。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如何降低火箭发射成本</span><br><span class="line">1. 造一个能容纳100人的火箭</span><br><span class="line">2. 实现火箭回收</span><br><span class="line">3. ....</span><br></pre></td></tr></table></figure><ul><li><p>大师程序员都是懂的去做任务分解，分解的力度是可执行</p></li><li><p>多写单元测试，代码小步提交</p></li></ul><p><img src="http://qiniu.deveye.cn/blog/img/20210514103356.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;以终为始&quot;&gt;以终为始&lt;/h3&gt;
&lt;p&gt;遇到问题不妨倒着去思考&lt;/p&gt;
&lt;h3 id=&quot;任务分解&quot;&gt;任务分解&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;埃隆马斯克SpaceX 的计划，本质上就是把一件很困难实现的事情去做任务分解，使每件任务可执行化。&lt;/li&gt;
&lt;/ul&gt;
&lt;fi</summary>
      
    
    
    
    <category term="读书" scheme="https://www.buzhidao.cc/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="读书" scheme="https://www.buzhidao.cc/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>golang开发hexo检索服务</title>
    <link href="https://www.buzhidao.cc/2021/04/12/golang%E5%BC%80%E5%8F%91hexo%E6%A3%80%E7%B4%A2%E6%9C%8D%E5%8A%A1/"/>
    <id>https://www.buzhidao.cc/2021/04/12/golang%E5%BC%80%E5%8F%91hexo%E6%A3%80%E7%B4%A2%E6%9C%8D%E5%8A%A1/</id>
    <published>2021-04-12T15:33:21.000Z</published>
    <updated>2025-06-12T02:00:43.934Z</updated>
    
    <content type="html"><![CDATA[<p>simple implementation <a href="https://github.com/YangKCoder/hexo-search">https://github.com/YangKCoder/hexo-search</a></p><ul><li>redisearch</li><li>colly</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;simple implementation &lt;a href=&quot;https://github.com/YangKCoder/hexo-search&quot;&gt;https://github.com/YangKCoder/hexo-search&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;redi</summary>
      
    
    
    
    <category term="golang" scheme="https://www.buzhidao.cc/categories/golang/"/>
    
    
    <category term="hexo" scheme="https://www.buzhidao.cc/tags/hexo/"/>
    
    <category term="golang" scheme="https://www.buzhidao.cc/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>阅读清单</title>
    <link href="https://www.buzhidao.cc/2021/04/09/%E9%98%85%E8%AF%BB%E6%B8%85%E5%8D%95/"/>
    <id>https://www.buzhidao.cc/2021/04/09/%E9%98%85%E8%AF%BB%E6%B8%85%E5%8D%95/</id>
    <published>2021-04-09T02:46:45.000Z</published>
    <updated>2025-06-12T02:00:43.936Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>序号</th><th>名称</th><th>状态</th></tr></thead><tbody><tr><td>1</td><td>《专栏: 10x程序员工作法》</td><td><strong>已完成</strong></td></tr><tr><td>2</td><td>《Java并发编程的艺术》</td><td><strong>进行中</strong></td></tr><tr><td>3</td><td>《高效能人士的七个习惯》</td><td><strong>已完成</strong></td></tr><tr><td>4</td><td>《自控力》</td><td><strong>已完成</strong></td></tr><tr><td>5</td><td>《关键对话》</td><td><strong>进行中</strong></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;状态&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;《专栏: 10x程序员工作法》&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;已完成&lt;/st</summary>
      
    
    
    
    <category term="读书" scheme="https://www.buzhidao.cc/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="读书" scheme="https://www.buzhidao.cc/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>10x程序员</title>
    <link href="https://www.buzhidao.cc/2021/04/08/10x%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    <id>https://www.buzhidao.cc/2021/04/08/10x%E7%A8%8B%E5%BA%8F%E5%91%98/</id>
    <published>2021-04-08T07:26:36.000Z</published>
    <updated>2025-06-12T02:00:43.932Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址: <a href="http://antirez.com/news/112">http://antirez.com/news/112</a></p></blockquote><p>坊间流传着“十倍程序员”的传说，所谓“十倍程序员”是指在同样时间内可以做“普通”程序员十倍的工作的程序员，而所谓“普通”是指那些擅长自己的领域，但不具有“十倍程序员”那样特殊魔力的程序员。更准确地说，普通程序员就是指那些具有平均编程效率的专业程序员。</p><p>在程序员群体中，对于“十倍程序员”的存在持有极度分化的观点：一些人认为这样的人绝不存在，另一些人则认为不仅存在，而且甚至存在“百倍程序员”。</p><p>如果你认为编程是一项线性工作（产出与劳动时间成正比的工作），那么显然“十倍程序员”是一种不合理的存在。一个跑步运动员不可能比对手跑得快十倍，一个建筑工人也不可能在同等时间建造十倍于别人的东西。然而，编程实际上是一项特殊的“设计”工作。此处设计不单指架构师的工作。即便不是项目的整体设计，当工程师具体实现它的时候，依然需要低层的实现策略的设计。</p><p>在我看来，程序的设计和实现不是一项线性工作。<em><strong>经验、代码能力、知识、对不重要事项的辨识能力都是不易量化的能力</strong></em>，<em><strong>这些能力的结合在程序开发中发挥重要作用</strong></em>，使程序员更高效。特别是当一个程序员需要全程参与到项目的设计与实现时，这些能力的优势更加明显。</p><p><em><strong>越是以结果为导向的任务越能激发高效程序员的能力</strong></em>。因为在结果导向的任务中，高效的程序员能够找到自己的方式，用更少的投入达到同样的效果。他们可以从顶层改变目标的实现路径，有时甚至直接去掉不必要的模块，来减少工作量而不影响目标的达成。而相对要求严格的项目，则会使这种效应减弱，因为程序员不得不受到诸如“使用某某工具”，“通过某某算法”的限制。虽然如此，高效程序员在这种多限制的情况下仍有其优势：他们可以发掘细节处优化实现的办法。</p><p>在我二十年的编程生涯中，始终观察我身边的程序员，无论我的同事、学徒，还是Redis或者其他项目的贡献者，以指导他们高效地达到既定目标。很多人说我是个很“快”的程序员。鉴于我不是个工作狂，所以我想以我为例来说明如何高效编程。</p><p>以下是我认为影响程序员工作效率的最主要因素：</p><h3 id="纯编程能力：不写一行多余代码"><strong>纯编程能力：不写一行多余代码</strong></h3><p>程序员的纯编程能力是程序员水平的最直接表现。在解决实际问题时候，程序员经常会被要求实现项目的某一个子模块，一个函数或者一个算法等等。令人惊讶的是，我发现在这个过程中，<em><strong>很少有人能够做到用最少的命令高效地完成任务</strong></em>。我甚至发现在很多团队中，竟然存在会忘记使用排序算法的不称职的程序员，这让他们甚至无法胜过虽然缺乏实践经验但理论完备的毕业生。</p><p><em><strong>解读：强调的是过硬编码能力</strong></em></p><h3 id="经验：踩在前人的肩膀上"><strong>经验：踩在前人的肩膀上</strong></h3><p>所谓经验，我指的是<em><strong>重复出现的任务的成熟解决方案</strong></em>。一个有经验的程序员知道如何处理各种任务。这可以避免重复设计，更重要的是可以避免设计错误，设计错误是程序员效率的最大敌人。</p><p><em><strong>解读：强调积累及思考的重要性</strong></em></p><h3 id="专注：高效利用时间"><em><strong>专注：高效利用时间</strong></em></h3><p>对于任何事情，时间的有效利用都至关重要，许多内在和外在的因素都会导致程序员丧失专注度。内在因素包括拖延症、没有兴趣、缺乏经验、睡眠短缺等。外在因素包括频繁的会议、工作环境、同事的干扰等。***提高专注度、避免打扰能够提高编程效率，***这很好理解。有时，为了专注，需要狠下心来，采取较为极端的措施。比如邮件，虽然都会看，但只回复很少的一部分。</p><p><em><strong>解读：专注</strong></em></p><h3 id="不要吝惜时间设计：防止推倒重来"><strong>不要吝惜时间设计：防止推倒重来</strong></h3><p>很多时候，程序员非常不情愿看到的一种情况是，需要在一些无关紧要的功能上浪费大量的时间，但你又不得不去将这个无关紧要的功能实现，因为它牵扯着这个项目的主要功能。这种时候，就需要反思，在顶层设计的时候是否考虑周全。详细而缜密的顶层设计能够减少上述情况的发生，即降低模块间的耦合性。对于项目的设计者来说，意识到每一个细小的模块都有可能成为项目的瓶颈，这很重要。对于项目而言，最终的目标是合理的时间做最大的产出，那么实施重点就应该放在项目最主要的模块上。拿我设计Disque（一个开源的分布式消息队列）为例，<em><strong>我意识到只要提供最优的消息排列方式，至于项目其他锦上添花的方面都可以后续慢慢补充</strong></em>，例如，可用性、查询语言、客户端交互、简易性及系统性能。</p><p><em><strong>解读：擒贼先擒王，重设计</strong></em></p><h3 id="简洁性：避免细节错误才是程序简洁的根本"><strong>简洁性：避免细节错误才是程序简洁的根本</strong></h3><p>简洁性意味着很多。为了理解什么是简洁性，首先来看看究竟可以多复杂？我相信导致复杂性有两个罪魁祸首，除了上面所说的不愿意花费过多的时间在设计上，还有一个是在设计过程中错误的累积。</p><p>思考一下程序实施的过程，所谓失之毫厘，谬以千里。一个初始的设计错误可能不会导致所在功能的重新设计，但可能会导致开发者需要在其他功能上做大量的工作来应对这个错误。因此，项目一步一步走向复杂和低效。</p><p>简洁性需要一步一步实现。<strong>程序员可以从最直接可靠的解决方式开始入手</strong>，用尽可能简单的方式实现功能，之后随着经验和编程能力的提高，程序员就有能力去优化设计了。</p><p>每次遇到不得不采取复杂的解决的方案的情况，开发者都应该花些时间想想如何避免这种情况的发生。只有在考虑了各种不同的方式，发现不得不走这条道路的时候，才继续在这个方向上前进。</p><p>解读：</p><h3 id="完美主义：高效产出的最大阻碍"><strong>完美主义：高效产出的最大阻碍</strong></h3><p>完美主义有两种类型，一种是追求至高性能的工程师文化，一种要符合个人趣向的执拗。两种情况都妨碍到程序员快速发布项目。完美主义和对外界评价的在乎会使程序员过多地将关注点放在一些细枝末节上，进而主观忽视项目的关键特性，<strong>例如程序的稳健性、简洁性、及是否能够按时交付</strong>。</p><p><em><strong>解读：避免完美主义，讲究实际</strong></em></p><h3 id="知识：某些关键问题还是要依靠理论解决"><strong>知识：某些关键问题还是要依靠理论解决</strong></h3><p><em><strong>当处理复杂的任务时：数据结构知识、对计算能力的极限的了解、对针对某个任务最行之有效的小众算法的了解，会帮助我们解决这些任务</strong></em>。对于开发者而言，对所有问题的所有解决方案都了如指掌这不现实，但对于某类问题的多数潜在解决方案都有所了解是必须的。例如，容许一定错误率，考虑概率集合基数估计量，可以设计一个优化的流的元素计数算法，避免复杂，缓慢，空间效率低下的缺点。</p><p><em><strong>解读：理论知识的重要性</strong></em></p><h3 id="底层：熟悉计算机的脾性"><strong>底层：熟悉计算机的脾性</strong></h3><p><em><strong>即便我们使用的是高级语言</strong></em>，<em><strong>但不了解计算机的内部运行机制仍然会导致一些问题</strong></em>。有时系统会出现涉及到底层问题的工具或算法错误，导致整个系统的重新设计实施。深入理解C语言、CPU运算机理和操作系统内核会避免我们遇到在项目后期“推倒重来”的情况。</p><p><em><strong>解读：底层的重要性</strong></em></p><h3 id="Debug能力：无需多言">Debug能力：无需多言</h3><p>寻找Bug总是非常耗费时间的。擅长发现、定位并合理地解决Bug，以及在编程过程中尽可能简化程序以减少Bug，这些素质将极大地提高程序员的编程效率</p><p><em><strong>解读：实战快速定位能力</strong></em></p><h3 id="总结">总结</h3><p>对于我来说，一个拥有以上素质的程序员，<em><strong>能表现出“十倍”于平庸程序员的效率是绝不意外的</strong></em>。往往，他们在项目开始的可行性研究阶段就能做出正确的决策，这样一来，数倍于常人的效率是很容易实现的。<em><strong>这种方式我称之为“取巧编程”，意思是在开发过程中的每一步都选择最优化的解决方案，花费最少的努力获得最大的用户体验。</strong></em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文地址: &lt;a href=&quot;http://antirez.com/news/112&quot;&gt;http://antirez.com/news/112&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;坊间流传着“十倍程序员”的传说，所谓“十倍程序员”是指</summary>
      
    
    
    
    <category term="其他" scheme="https://www.buzhidao.cc/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="其他" scheme="https://www.buzhidao.cc/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Thread详解</title>
    <link href="https://www.buzhidao.cc/2021/03/27/Thread%E8%AF%A6%E8%A7%A3/"/>
    <id>https://www.buzhidao.cc/2021/03/27/Thread%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-03-27T02:10:27.000Z</published>
    <updated>2025-06-12T02:00:43.934Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载自: <a href="https://www.cnblogs.com/sanzao/p/10528677.html">https://www.cnblogs.com/sanzao/p/10528677.html</a></p></blockquote><p>本文主要结合 <code>java.lang.Thread</code> 源码，梳理 Java 线程的整体脉络；</p><h2 id="一、线程概述">一、线程概述</h2><p>对于 Java 中的线程主要是依赖于系统的 API 实现的，这一点可以从 <code>java.lang.Thread</code>；源码中关键的方法都是 <code>native</code> 方法看出，也可以直接查看 OpenJDK 源码看出来，这一点后面还会讲到；对于 JDK1.8 而言，他的 Windows 版和 Linux 版使用的都是 <strong>1:1 线程模型</strong>，即系统内核线程和轻量级进程的比是 <code>1:1</code>；</p><ul><li>内核线程（Kernel-Level Thread，KLT）：是由操作系统内核（Kernel）直接支持的线程，这种线程由内核来完成切换，内核通过调度器（Schedule）进行调度，并负责将线程的任务映射到各个处理器上；</li><li>轻量级进程（Light Weight Process，LWP）：程序可以直接使用的一种内核线程高级接口，也就是我们通常意义上的线程；</li></ul><p>如图所示：</p><p><img src="http://qiniu.deveye.cn/blog/img/20210327102908.png" alt=""></p><p><strong>优点：</strong></p><ul><li>由内核线程的支持，每个线程都成为一个独立的调度单元，即线程之间不会相互阻塞影响；使用内核提供的线程调度功能及处理器映射，可以完成线程的切换，并将线程的任务映射到其他处理器上，充分利用多核处理器的优势，实现真正的并行。</li></ul><p><strong>缺点：</strong></p><ul><li>同时由于基于内核线程实现，线程的创建、关闭、同步等操作都需要系统调用；需要在用户态和内核态之间切换，代价相对较高；</li><li>另外每个线程都需要消耗一定的内核资源，如内核线程的栈空间，所以系统支持的轻量级进程是有限的；</li></ul><h2 id="二、线程状态">二、线程状态</h2><p>Java 线程的整个生命周期可能会经历以下5中状态，如图所示：</p><p><img src="http://qiniu.deveye.cn/blog/img/20210327100935.png" alt=""></p><ul><li>新建（New）：新建后未启动的线程；</li><li>运行（Runnable）：包括运行中（Running）和就绪（Ready）两种状态；也就是正在运行，或者等待 CPU 分配执行时间；</li><li>等待（Waiting）：无限期的等待其他线程显示唤醒；</li><li>超时等待（Timed_Waiting）：一定时间内没有被其他线程唤醒，则由系统自动唤醒；</li><li>阻塞（Blocked）：等待获取排它锁；</li><li>终止（Terminated）：运行终止；</li></ul><h2 id="三、源码分析">三、源码分析</h2><h3 id="1-native注册">1. native注册</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Make sure registerNatives is the first thing &lt;clinit&gt; does. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">registerNatives</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  registerNatives();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在很多地方都出现过，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.System</span><br><span class="line">java.lang.Object</span><br><span class="line">java.lang.Class</span><br></pre></td></tr></table></figure><p>其作用就是在使用 JNI 时需要向 JVM 注册，其方法名默认为 <code>Java_&lt;fully qualified class name&gt;_method</code>；但是如果觉得这样的名字太长，这是就可以使用 <code>registerNatives()</code> 向 JVM 注册任意的函数名；</p><p>Thread 中的 native 方法有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">stop0</span><span class="params">(Object o)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">suspend0</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">resume0</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setPriority0</span><span class="params">(<span class="type">int</span> newPriority)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title function_">currentThread</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">countStackFrames</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">interrupt0</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">(<span class="type">boolean</span> ClearInterrupted)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">holdsLock</span><span class="params">(Object obj)</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> Thread[] getThreads();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> StackTraceElement[][] dumpThreads(Thread[] threads);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setNativeName</span><span class="params">(String name)</span>;</span><br></pre></td></tr></table></figure><p>其对应 JVM 源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// openjdk\jdk\src\share\native\java\lang\Thread.c</span></span><br><span class="line"><span class="type">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;start0&quot;</span>,           <span class="string">&quot;()V&quot;</span>,              (<span class="type">void</span> *)&amp;JVM_StartThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;stop0&quot;</span>,            <span class="string">&quot;(&quot;</span> OBJ <span class="string">&quot;)V&quot;</span>,       (<span class="type">void</span> *)&amp;JVM_StopThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;isAlive&quot;</span>,          <span class="string">&quot;()Z&quot;</span>,              (<span class="type">void</span> *)&amp;JVM_IsThreadAlive&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;suspend0&quot;</span>,         <span class="string">&quot;()V&quot;</span>,              (<span class="type">void</span> *)&amp;JVM_SuspendThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;resume0&quot;</span>,          <span class="string">&quot;()V&quot;</span>,              (<span class="type">void</span> *)&amp;JVM_ResumeThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;setPriority0&quot;</span>,     <span class="string">&quot;(I)V&quot;</span>,             (<span class="type">void</span> *)&amp;JVM_SetThreadPriority&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;yield&quot;</span>,            <span class="string">&quot;()V&quot;</span>,              (<span class="type">void</span> *)&amp;JVM_Yield&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;sleep&quot;</span>,            <span class="string">&quot;(J)V&quot;</span>,             (<span class="type">void</span> *)&amp;JVM_Sleep&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;currentThread&quot;</span>,    <span class="string">&quot;()&quot;</span> THD,           (<span class="type">void</span> *)&amp;JVM_CurrentThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;countStackFrames&quot;</span>, <span class="string">&quot;()I&quot;</span>,              (<span class="type">void</span> *)&amp;JVM_CountStackFrames&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;interrupt0&quot;</span>,       <span class="string">&quot;()V&quot;</span>,              (<span class="type">void</span> *)&amp;JVM_Interrupt&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;isInterrupted&quot;</span>,    <span class="string">&quot;(Z)Z&quot;</span>,             (<span class="type">void</span> *)&amp;JVM_IsInterrupted&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;holdsLock&quot;</span>,        <span class="string">&quot;(&quot;</span> OBJ <span class="string">&quot;)Z&quot;</span>,       (<span class="type">void</span> *)&amp;JVM_HoldsLock&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;getThreads&quot;</span>,        <span class="string">&quot;()[&quot;</span> THD,         (<span class="type">void</span> *)&amp;JVM_GetAllThreads&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;dumpThreads&quot;</span>,      <span class="string">&quot;([&quot;</span> THD <span class="string">&quot;)[[&quot;</span> STE, (<span class="type">void</span> *)&amp;JVM_DumpThreads&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;setNativeName&quot;</span>,    <span class="string">&quot;(&quot;</span> STR <span class="string">&quot;)V&quot;</span>,       (<span class="type">void</span> *)&amp;JVM_SetNativeThreadName&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其具体实现可以查看</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openjdk\hotspot\src\share\vm\prims\jvm.h</span><br><span class="line">openjdk\hotspot\src\share\vm\prims\jvm.cpp</span><br></pre></td></tr></table></figure><h3 id="2-构造方法和成员变量">2. 构造方法和成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> String name;        <span class="comment">// 线程名称，如果没有指定，就通过 Thread-线程序列号 命名</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> priority;                <span class="comment">// 线程优先级，1-10 默认与父线程优先级相同(main 线程优先级为 5)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">daemon</span> <span class="operator">=</span> <span class="literal">false</span>;      <span class="comment">// 是否是守护线程</span></span><br><span class="line">  <span class="keyword">private</span> Runnable target;             <span class="comment">// Runnable 对象</span></span><br><span class="line">  <span class="keyword">private</span> ThreadGroup group;           <span class="comment">// 所属线程组</span></span><br><span class="line">  ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;             <span class="comment">// 线程本地变量</span></span><br><span class="line">  ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;  <span class="comment">// 可继承的线程本地变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> tid;                                           <span class="comment">// 线程 tid</span></span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">()</span> &#123;</span><br><span class="line">    init(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target)</span> &#123;</span><br><span class="line">    init(<span class="literal">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(ThreadGroup group, Runnable target)</span> &#123;</span><br><span class="line">    init(group, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    init(<span class="literal">null</span>, <span class="literal">null</span>, name, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(ThreadGroup group, String name)</span> &#123;</span><br><span class="line">    init(group, <span class="literal">null</span>, name, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target, String name)</span> &#123;</span><br><span class="line">    init(<span class="literal">null</span>, target, name, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(ThreadGroup group, Runnable target, String name)</span> &#123;</span><br><span class="line">    init(group, target, name, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(ThreadGroup group, Runnable target, String name, <span class="type">long</span> stackSize)</span> &#123;</span><br><span class="line">    init(group, target, name, stackSize);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name, <span class="type">long</span> stackSize, AccessControlContext acc, <span class="type">boolean</span> inheritThreadLocals)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">parent</span> <span class="operator">=</span> currentThread();</span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (g == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">        g = security.getThreadGroup();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (g == <span class="literal">null</span>) &#123;</span><br><span class="line">        g = parent.getThreadGroup();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    g.checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">        security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.addUnstarted();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.group = g;</span><br><span class="line">    <span class="built_in">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="built_in">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="keyword">if</span> (security == <span class="literal">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">      <span class="built_in">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="built_in">this</span>.inheritedAccessControlContext = acc != <span class="literal">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    <span class="built_in">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="literal">null</span>)</span><br><span class="line">      <span class="built_in">this</span>.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="built_in">this</span>.stackSize = stackSize;</span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到左右的构造方法最终都会调用 <code>init()</code>；并初始化所属线程组、名字、 Runnable、栈大小等信息；整个过程相当于配置了一个线程工厂，此时只是初始化了所有的配置，线程还没有真正创建，当然资源同样也还没有分配，只有在调用 <code>start()</code> 的时候线程才会真正创建；</p><p>此外可以看到线程创建过程中会有很多的权限检查，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line"><span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">    security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下权限的检查默认是没有开启的，所以 <code>security</code> 一直都是 <code>null</code> ；这里需要在启动 JVM 的时候指定 <code>-Djava.security.manager</code> ；当然也可以指定特定的 <code>SecurityManager</code>；但是在开启的时候很可能会遇到类似：<code>java.security.AccessControlException: access denied</code> ；权限检查失败的错误；</p><p>此时可以在 <code>jre\lib\security\java.policy</code> 中添加相应的权限；或者直接开启所有权限 <code>permission java.security.AllPermission;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jre\lib\security\java.policy</span></span><br><span class="line"></span><br><span class="line">grant &#123;</span><br><span class="line">  permission java.lang.RuntimePermission <span class="string">&quot;stopThread&quot;</span>;</span><br><span class="line">  permission java.net.SocketPermission <span class="string">&quot;localhost:0&quot;</span>, <span class="string">&quot;listen&quot;</span>;</span><br><span class="line">  permission java.util.PropertyPermission <span class="string">&quot;java.version&quot;</span>, <span class="string">&quot;read&quot;</span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  permission java.security.AllPermission;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-start-方法">3. start 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">  group.add(<span class="built_in">this</span>);</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    start0();</span><br><span class="line">    started = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">        group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>可以看到这是一个同步方法，并且同一个线程不能启动两次；这里首先将线程加入对应的线程组，再真正创建线程，如果创建失败就在线程组中标记；对应的这个 <code>native</code> 方法 <code>start0</code> ，的源码同样可以查看 <code>openjdk\hotspot\src\share\vm\prims\jvm.cpp</code>，这里就不详细介绍了；</p><h3 id="4-exit-方法">4. exit 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (group != <span class="literal">null</span>) &#123;</span><br><span class="line">    group.threadTerminated(<span class="built_in">this</span>);</span><br><span class="line">    group = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Aggressively null out all reference fields: see bug 4006245 */</span></span><br><span class="line">  target = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">/* Speed the release of some of these resources */</span></span><br><span class="line">  threadLocals = <span class="literal">null</span>;</span><br><span class="line">  inheritableThreadLocals = <span class="literal">null</span>;</span><br><span class="line">  inheritedAccessControlContext = <span class="literal">null</span>;</span><br><span class="line">  blocker = <span class="literal">null</span>;</span><br><span class="line">  uncaughtExceptionHandler = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>exit</code> 方法则是由系统调用，在 Thread 销毁前释放资源；</p><h3 id="5-弃用方法">5. 弃用方法</h3><p>在源码里面还有几个弃用的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123; &#125;            <span class="comment">// 停止线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">suspend</span><span class="params">()</span> &#123; &#125;         <span class="comment">// 暂停线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">resume</span><span class="params">()</span> &#123; &#125;          <span class="comment">// 恢复线程</span></span><br></pre></td></tr></table></figure><ul><li>stop：停止线程会导致它解锁已锁定的所有监视器，从而产生同步问题，因为它本质上是不安全的。</li><li>suspend：暂停线程容易出现死锁，如果目标线程在监视器上保持锁定，那么在恢复目标线程之前，任何线程都无法访问此资源。</li><li>resume：恢复线程同样容易出现死锁， 如果 A 线程在恢复 B 线程之前锁定监视器，然后在调用 resume 恢复 B，此时 B 会尝试再次获取锁，这样就会导致死锁。</li></ul><h2 id="四、线程通讯">四、线程通讯</h2><p>其实所有的多线程问题，其本质都是线程之间的通讯问题，也有的说是通讯和同步两个问题（线程间操作的顺序）；但我觉得同步仍然是线程之间通过某种方式进行通讯，确定各自执行的相对顺序；所以仍然可以算作是一种通讯问题；这里线程之间的通讯问题可以分成两种：</p><ul><li>共享变量，类似锁对象、volatile、中断等操作都可以算是共享变量通讯；</li><li>消息传递，类似 wait\notify、管道等则可以算是通过消息直接传递通讯；</li></ul><p>下面我们将介绍和 Thread 类直接相关的几种通讯，关于锁的部分之后的博客还会详细介绍；</p><h3 id="1-wait-notify-机制">1. wait\notify 机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotify</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">waitThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Wait</span>(), <span class="string">&quot;WaitThread&quot;</span>);</span><br><span class="line">    waitThread.start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">notifyThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Notify</span>(), <span class="string">&quot;NotifyThread&quot;</span>);</span><br><span class="line">    notifyThread.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Wait</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 加锁，拥有lock的Monitor</span></span><br><span class="line">      <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">        <span class="comment">// 当条件不满足时，继续wait，同时释放了lock的锁</span></span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;flag is true. wait&quot;</span>);</span><br><span class="line">            LOCK.wait();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 条件满足时，完成工作</span></span><br><span class="line">        log.info(<span class="string">&quot;flag is false. running&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Notify</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 加锁，拥有lock的Monitor</span></span><br><span class="line">      <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">        <span class="comment">// 获取lock的锁，然后进行通知，通知时不会释放lock的锁，</span></span><br><span class="line">        <span class="comment">// 直到当前线程释放了lock后，WaitThread才能从wait方法中返回</span></span><br><span class="line">        log.info(<span class="string">&quot;hold lock. notify&quot;</span>);</span><br><span class="line">        LOCK.notify();</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        SleepUtils.second(<span class="number">5</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 再次加锁</span></span><br><span class="line">      <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;hold lock again. sleep&quot;</span>);</span><br><span class="line">        SleepUtils.second(<span class="number">5</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[13 21:18:18,533 INFO ] [WaitThread]   WaitNotify - flag is true. wait</span><br><span class="line">[13 21:18:19,533 INFO ] [NotifyThread] WaitNotify - hold lock. notify</span><br><span class="line">[13 21:18:24,535 INFO ] [NotifyThread] WaitNotify - hold lock again. sleep</span><br><span class="line">[13 21:18:29,536 INFO ] [WaitThread]   WaitNotify - flag is false. running</span><br></pre></td></tr></table></figure><h3 id="2-join">2. join</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Join</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">previous</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// 每个线程拥有前一个线程的引用，需要等待前一个线程终止，才能从等待中返回</span></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Domino</span>(previous), String.valueOf(i));</span><br><span class="line">      thread.start();</span><br><span class="line">      previous = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    log.info(<span class="string">&quot;terminate.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Domino</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Domino</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        thread.join();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      log.info(<span class="string">&quot;terminate.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[13 21:27:27,573 INFO ] [main] Join - terminate.</span><br><span class="line">[13 21:27:27,574 INFO ] [0]    Join - terminate.</span><br><span class="line">[13 21:27:27,574 INFO ] [1]    Join - terminate.</span><br><span class="line">[13 21:27:27,574 INFO ] [2]    Join - terminate.</span><br><span class="line">[13 21:27:27,574 INFO ] [3]    Join - terminate.</span><br><span class="line">[13 21:27:27,574 INFO ] [4]    Join - terminate.</span><br></pre></td></tr></table></figure><h3 id="3-interrupt">3. interrupt</h3><p>以上 <code>wait\notify、join</code> 都比较简单，大家直接看代码应该就能理解；但是 <code>interrupt 机制</code> 则比较复杂一点，我们先从源码分析；</p><p><strong>interrupt 方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Interruptible blocker;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">blockerLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the blocker field; invoked via sun.misc.SharedSecrets from java.nio code</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">blockedOn</span><span class="params">(Interruptible b)</span> &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">    blocker = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span> != Thread.currentThread()) checkAccess();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">    <span class="type">Interruptible</span> <span class="variable">b</span> <span class="operator">=</span> blocker;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;</span><br><span class="line">      interrupt0();       <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">      b.interrupt(<span class="built_in">this</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  interrupt0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">interrupt0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>在 Thread 的源码上有详细的注释，以下我简单翻译：</p><ul><li>如果线程处于 <strong>WAITINF、TIMED_WAITING</strong> （正阻塞于 Object 类的 wait()、wait(long)、wait(long, int)方法，或者 Thread 类的 join()、join(long)、join(long, int)、sleep(long)、sleep(long, int)方法），则该线程的中断状态将被清除，并收到一个 <code>java.lang.InterruptedException</code>；</li><li>如果线程正阻塞于 <strong>InterruptibleChannel</strong> 上的 I/O 操作，则该通道将被关闭，同时该线程的中断状态被设置，并收到一个<code>java.nio.channels.ClosedByInterruptException</code>；</li><li>如果线程正阻塞于 <strong>java.nio.channels.Selector</strong> 操作，则该线程的中断状态被设置，同时它将立即从选择操作返回，并可能带有一个非零值，其效果同 <code>java.nio.channels.Selector.wakeup()</code> 方法一样；</li><li>如果上述条件都不成立，则该线程的中断状态将被设置；</li></ul><p>其中 <code>Interruptible blocker</code> 就是在 <code>NIO</code> 操作的时候通过 <code>sun.misc.SharedSecrets</code> 设置的（其效果同反射，但是不会生成其他对象，也就是不会触发 OOM）；</p><p><strong>interrupted 、isInterrupted 方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> currentThread().isInterrupted(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> isInterrupted(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">(<span class="type">boolean</span> ClearInterrupted)</span>;</span><br></pre></td></tr></table></figure><p>可以很清楚的看到他们都是通过 <code>isInterrupted(boolean ClearInterrupted)</code> 方法实现的，但是 <code>interrupted</code> 会清除中断状态，而 <code>isInterrupted</code> 则不会清除；</p><p>以上 <code>interrupt 机制</code> 就通过设置 <code>interrupt flag</code>，查询中断状态，以及中断异常构成了一套完整的通讯机制；也可以看作是通过 <code>interrupt flag</code> 共享变量实现的，下面我们简单举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interrupted</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// sleepThread不停的尝试睡眠</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">sleepThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SleepRunner</span>(), <span class="string">&quot;SleepThread&quot;</span>);</span><br><span class="line">    sleepThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// busyThread不停的运行</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">busyThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">BusyRunner</span>(), <span class="string">&quot;BusyThread&quot;</span>);</span><br><span class="line">    busyThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">    sleepThread.start();</span><br><span class="line">    busyThread.start();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 休眠5秒，让sleepThread和busyThread充分运行</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    sleepThread.interrupt();</span><br><span class="line">    busyThread.interrupt();</span><br><span class="line">    log.info(<span class="string">&quot;SleepThread interrupted is &#123;&#125;&quot;</span>, sleepThread.isInterrupted());</span><br><span class="line">    log.info(<span class="string">&quot;BusyThread interrupted is &#123;&#125;&quot;</span>, busyThread.isInterrupted());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止sleepThread和busyThread立刻退出</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    log.info(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SleepRunner</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">          Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;SleepThread interrupted is &#123;&#125;&quot;</span>, Thread.currentThread().isInterrupted());</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        log.error(<span class="string">&quot;SleepThread interrupted is &#123;&#125;&quot;</span>, Thread.currentThread().isInterrupted());</span><br><span class="line">      &#125;</span><br><span class="line">      log.info(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BusyRunner</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      log.info(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[14 10:20:55,269 INFO ] [main]        Interrupted - SleepThread interrupted is false</span><br><span class="line">[14 10:20:55,269 ERROR] [SleepThread] Interrupted - SleepThread interrupted is false</span><br><span class="line">[14 10:20:55,270 INFO ] [main]        Interrupted - BusyThread interrupted is true</span><br><span class="line">[14 10:20:55,270 ERROR] [SleepThread] Interrupted - SleepThread interrupted is true</span><br><span class="line">[14 10:20:55,271 INFO ] [SleepThread] Interrupted - exit</span><br><span class="line">[14 10:21:00,271 INFO ] [main]        Interrupted - exit</span><br></pre></td></tr></table></figure><p>从日志中可以看到：</p><ul><li>打断的确是一个标记，对于未处于可打断状态的线程，或者没有处理打断状态的线程是没有影响的，就像 BusyThread；</li><li>使用 interrupt 打断睡眠线程，也的确符合上面的情况，但是因为收到 <code>InterruptedException</code> 的时候会清楚中断标记，所以这里可以再次设置中断标记；</li></ul><p>当然以上只是简单的举例，中断机制如何使用还是要根据具体的业务逻辑来确定；另外以上的实例代码是出自《Java 并发编程的艺术》，有兴趣的也可以找书来看一下；</p><h2 id="总结">总结</h2><ul><li>以上的内容其主要目的是为了帮助你构建一个相对完善的线程知识体系，其中还有很多的细节没有讲到，具体内容还需要结合实际场景分析；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;转载自: &lt;a href=&quot;https://www.cnblogs.com/sanzao/p/10528677.html&quot;&gt;https://www.cnblogs.com/sanzao/p/10528677.html&lt;/a&gt;&lt;/p&gt;
&lt;/block</summary>
      
    
    
    
    <category term="多线程" scheme="https://www.buzhidao.cc/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.buzhidao.cc/tags/Java/"/>
    
    <category term="多线程" scheme="https://www.buzhidao.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java将HTML转为图片</title>
    <link href="https://www.buzhidao.cc/2021/03/25/Java-HTML-%E8%BD%AC%E5%9B%BE%E7%89%87/"/>
    <id>https://www.buzhidao.cc/2021/03/25/Java-HTML-%E8%BD%AC%E5%9B%BE%E7%89%87/</id>
    <published>2021-03-25T14:13:35.000Z</published>
    <updated>2025-06-12T02:00:43.933Z</updated>
    
    <content type="html"><![CDATA[<p><strong>记录一个使用Java转图片的第三方工具</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/net.sf.cssbox/cssbox --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;net.sf.cssbox&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;cssbox&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;5.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>使用方法很简单，伪代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ImageRenderer render = new ImageRenderer();</span><br><span class="line">ByteArrayOutputStream os = new ByteArrayOutputStream();</span><br><span class="line">//创建一个临时的HTML文件</span><br><span class="line">Path tempFile = Files.createTempFile(IdWorker.getMillisecond(), &quot;.html&quot;);</span><br><span class="line">//将HTML字节流写入到临时文件中</span><br><span class="line">Files.write(tempFile,createHtml());</span><br><span class="line">render.renderURL(tempFile.toUri().toString(), os);</span><br><span class="line">String fileName = &quot;test.png&quot;;</span><br><span class="line">//将图片上传到OSS</span><br><span class="line">AliyunOSSUtil.upload(AliyunOSSUtil.toOSSFilePath(fileName, sysUser.tenantId()), new  ByteArrayInputStream(os.toByteArray()));</span><br><span class="line">//删除临时文件</span><br><span class="line">Files.deleteIfExists(tempFile);</span><br></pre></td></tr></table></figure><p>我的方案是使用<code>freemarker</code>模板引擎先将数据渲染到成html文件，然后通过html文件生成一个图片，将图片上传到OSS中，最后删除临时生成的html文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;记录一个使用Java转图片的第三方工具&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa</summary>
      
    
    
    
    <category term="Java" scheme="https://www.buzhidao.cc/categories/Java/"/>
    
    
    <category term="Java" scheme="https://www.buzhidao.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java的字符串常量池位于哪里，堆或堆栈？</title>
    <link href="https://www.buzhidao.cc/2021/03/24/Java%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%BD%8D%E4%BA%8E%E5%93%AA%E9%87%8C%EF%BC%8C%E5%A0%86%E6%88%96%E5%A0%86%E6%A0%88%EF%BC%9F/"/>
    <id>https://www.buzhidao.cc/2021/03/24/Java%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%BD%8D%E4%BA%8E%E5%93%AA%E9%87%8C%EF%BC%8C%E5%A0%86%E6%88%96%E5%A0%86%E6%A0%88%EF%BC%9F/</id>
    <published>2021-03-24T14:16:44.000Z</published>
    <updated>2025-06-12T02:00:43.933Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载自: <a href="https://www.baeldung.com/java-string-constant-pool-heap-stack">https://www.baeldung.com/java-string-constant-pool-heap-stack</a></p></blockquote><h3 id="1-简介">1.简介</h3><p>每当我们声明一个变量或创建一个对象时，它就会存储在内存中。在较高的级别上，Java将内存分为两个块：<code>stack</code>和<code>heap</code>。<strong>两种存储器均存储特定类型的数据</strong>，并且具有不同的存储和访问模式。</p><h3 id="2-字符串常量池">2.字符串常量池</h3><p>该字符串常量池是一个特殊的存储区。**当我们声明<code>String</code>时，JVM在池中创建对象并将其引用存储在堆栈中。**在内存中创建每个<em>String</em>对象之前，JVM执行一些步骤来减少内存开销。</p><p>字符串常量池在其实现中使用HashMap。<em>HashMap的</em>每个存储桶<em>均</em>包含具有相同哈希码的<em>String</em>列表。在Java的早期版本中，池的存储区域是固定大小的，并且通常会导致*“无法为对象堆保留足够的空间”* 错误。</p><p>**当系统加载类时，所有类的*String*文字都将进入应用程序级池。**这是因为不同类的相等<em>String</em>文字必须是相同的<em>Object</em>。在这些情况下，池中的数据应可用于每个类而没有任何依赖关系。</p><p>通常，堆栈存储短期的数据。它包括局部基本变量，堆对象的引用以及执行中的方法。堆允许动态分配内存，在运行时存储Java对象和JRE类。</p><p>堆允许全局访问，并且在应用程序的生存期内，堆中的数据存储可用于所有线程，而堆栈上的数据存储具有私有作用域，只有所有者线程可以访问它们。</p><p>堆栈将数据存储在连续的存储块中，并允许随机访问。如果类需要池中的随机<em>String</em>，则由于堆栈的LIFO（后进先出）规则，该类可能不可用。相反，堆会动态分配内存，并允许我们以任何方式访问数据。</p><p>假设我们有一个由不同类型的变量组成的代码段。堆栈将存储<em>int</em>文字的值以及<em>String</em>和Demo对象的引用*。<em>任何对象的值都将存储在堆中，所有</em>String*文字都放入堆中的池中：</p><p><img src="http://qiniu.deveye.cn/blog/img/20210324222316.png" alt=""></p><p>线程完成执行后，将立即释放在堆栈上创建的变量。相反，垃圾收集器回收堆中的资源。同样，垃圾收集器从池中收集未引用的项目。</p><p>**池的默认大小在不同平台上可能会有所不同。**无论如何，它仍然比可用堆栈大小大得多。在JDK 7之前，该池是permgen空间的一部分，从JDK 7到现在，它是主堆内存的一部分。</p><h2 id="3-结论">3.结论</h2><p>在这篇简短的文章中，我们了解了<em>String</em>常量池的存储区域。堆栈和堆具有不同的特性来存储和访问数据。从内存分配到其访问和可用性，堆是最适合存储String常量池的区域。</p><p><strong>实际上，池从未成为堆栈内存的一部分。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;转载自: &lt;a href=&quot;https://www.baeldung.com/java-string-constant-pool-heap-stack&quot;&gt;https://www.baeldung.com/java-string-constant-p</summary>
      
    
    
    
    <category term="Java" scheme="https://www.buzhidao.cc/categories/Java/"/>
    
    
    <category term="Java" scheme="https://www.buzhidao.cc/tags/Java/"/>
    
    <category term="String" scheme="https://www.buzhidao.cc/tags/String/"/>
    
    <category term="转载" scheme="https://www.buzhidao.cc/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>后端学习路线</title>
    <link href="https://www.buzhidao.cc/2021/03/24/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <id>https://www.buzhidao.cc/2021/03/24/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</id>
    <published>2021-03-24T11:39:04.000Z</published>
    <updated>2025-06-12T02:00:43.935Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GitHub的一个学习路线仓库">GitHub的一个学习路线仓库</h3><p><a href="https://github.com/kamranahmedse/developer-roadmap">https://github.com/kamranahmedse/developer-roadmap</a></p><p><img src="http://qiniu.deveye.cn/blog/img/20210324193846.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;GitHub的一个学习路线仓库&quot;&gt;GitHub的一个学习路线仓库&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kamranahmedse/developer-roadmap&quot;&gt;https://github.com/kamranahmed</summary>
      
    
    
    
    <category term="学习" scheme="https://www.buzhidao.cc/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="https://www.buzhidao.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C 同步框架（AQS 框架）</title>
    <link href="https://www.buzhidao.cc/2021/03/22/JUC%E5%90%8C%E6%AD%A5%E6%A1%86%E6%9E%B6-AQS/"/>
    <id>https://www.buzhidao.cc/2021/03/22/JUC%E5%90%8C%E6%AD%A5%E6%A1%86%E6%9E%B6-AQS/</id>
    <published>2021-03-22T07:39:43.000Z</published>
    <updated>2025-06-12T02:00:43.933Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载自：<a href="https://www.cnblogs.com/dennyzhangdd/p/7218510.html">https://www.cnblogs.com/dennyzhangdd/p/7218510.html</a></p></blockquote><h1>一、论文简介</h1><p>闲来无事，看看源码，发现了一篇JDK作者的论文《The java.util.concurrent Synchronizer Framework》主要描述了作者对 <code>AbstractQueuedSynchronizer</code> 同步器框架的设计和实现。权威性毋庸置疑！自然需要拜读一下，配上中文翻译，希望大家能有所收获。</p><h1>二、原文链接</h1><p>论文英文版原文链接：<a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf">http://gee.cs.oswego.edu/dl/papers/aqs.pdf</a></p><p><a href="http://gee.cs.oswego.edu/">http://gee.cs.oswego.edu/</a> 这个是老李头的主页，里面有他的部分贡献，感兴趣的可以关注一下，老李头确实比较厉害。</p><h1>三、中文翻译</h1><h2 id="摘要">摘要</h2><p>在 J2SE 1.5 的 <code>java.util.concurrent</code> 包（下称 j.u.c 包）中，大部分的同步器（例如锁，屏障等等）都是基于 <code>AbstractQueuedSynchronizer</code> 类（下称 AQS 类），这个简单的框架而构建的。这个框架为同步状态的原子性管理、线程的阻塞和解除阻塞以及排队提供了一种通用的机制。这篇论文主要描述了这个框架基本原理、设计、实现、用法以及性能。</p><h2 id="1-背景介绍">1. 背景介绍</h2><p>通过 JCP 的 <code>JSR166</code> 规范，Java 的 1.5 版本引入了 j.u.c 包，这个包提供了一系列支持中等程度并发的类。这些组件是一系列的同步器（抽象数据类型(ADT)）。这些同步器主要维护着以下几个功能：内部同步状态的管理(例如：表示一个锁的状态是获取还是释放)，同步状态的更新和检查操作，且至少有一个方法会导致调用线程在同步状态被获取时阻塞，以及在其他线程改变这个同步状态时解除线程的阻塞。上述的这些的实际例子包括：<strong>互斥排它锁的不同形式、读写锁、信号量、屏障、Future、事件指示器以及传送队列等</strong>。</p><p>几乎任一同步器都可以用来实现其他形式的同步器。例如，可以用可重入锁实现信号量或者用信号量实现可重入锁。但是，这样做带来的复杂性，开销，不灵活使其至多只能是个二流工程，且缺乏吸引力。如果任何这样的构造方式不能在本质上比其他形式更简洁，那么开发者就不应该随意地选择其中的某个来构建另一个同步器。取而代之，JSR166 建立了一个小框架，AQS 类。这个框架为构造同步器提供一种通用的机制，并且被 <code>j.u.c</code> 包中大部分类使用，同时很多用户也用它来定义自己的同步器。</p><p>在这篇论文的下面部分会讨论这个框架的需求、设计与实现背后的主要思路、示例用法，以及性能指标的一些测量。</p><h2 id="2-需求">2 需求</h2><h3 id="2-1-功能">2.1 功能</h3><p>同步器一般包含两种方法，一种是 <code>acquire</code>，另一种是 <code>release</code>。<code>acquire</code> 操作阻塞调用的线程，直到或除非同步状态允许其继续执行。而 <code>release</code> 操作则是通过某种方式改变同步状态，使得一或多个被 <code>acquire</code> 阻塞的线程继续执行。</p><p>j.u.c 包中并没有对同步器的API做一个统一的定义。因此，有一些类定义了通用的接口（如 Lock），而另外一些则定义了其专有的版本。因此在不同的类中，<code>acquire</code> 和 <code>release</code> 操作的名字和形式会各有不同。例如：<code>Lock.lock</code>，<code>Semaphore.acquire</code>，<code>CountDownLatch.await</code> 和 <code>FutureTask.get</code>，在这个框架里，这些方法都是 <code>acquire</code> 操作。但是，J.U.C 为支持一系列常见的使用选项，在类间都有个一致约定。在有意义的情况下，每一个同步器都支持下面的操作：</p><ul><li>阻塞和非阻塞（例如 <code>tryLock</code>）同步</li><li>可选的超时设置，让调用者可以放弃等待</li><li>通过中断实现的任务取消，通常是分为两个版本，一个 <code>acquire</code> 可取消，而另一个不可以</li></ul><p>同步器的实现根据其状态是否独占而有所不同。独占状态的同步器，在同一时间只有一个线程可以通过阻塞点，而共享状态的同步器可以同时有多个线程在执行。一般锁的实现类往往只维护独占状态，但是，例如计数信号量在数量许可的情况下，允许多个线程同时执行。为了使框架能得到广泛应用，这两种模式都要支持。</p><p>j.u.c 包里还定义了 <code>Condition</code> 接口，用于支持监控形式的 <code>await/signal</code> 操作，这些操作与独占模式的 <code>Lock</code> 类有关，且 <code>Condition</code> 的实现天生就和与其关联的 <code>Lock</code> 类紧密相关。</p><h3 id="2-2-性能目标">2.2 性能目标</h3><p>Java 内置锁（使用 <code>synchronized</code> 的方法或代码块）的性能问题一直以来都在被人们关注，并且已经有一系列的文章描述其构造（例如引文 [<sup>1],[</sup>3]）。然而，大部分的研究主要关注的是在单核处理器上大部分时候使用于单线程上下文环境中时，如何尽量降低其空间（因为任何的 Java 对象都可以当成是锁）和时间的开销。对于同步器来说这些都不是特别重要：程序员仅在需要的时候才会使用同步器，因此并不需要压缩空间来避免浪费，并且同步器几乎是专门用在多线程设计中（特别是在多核处理器上），在这种环境下，偶尔的竞争是在意料之中的。因此，常规的 JVM 锁优化策略主要是针对零竞争的场景，而其它场景则使用缺乏可预见性的“慢速路径（slow paths）” ，所以常规的JVM锁优化策略并不适用于严重依赖于 J.U.C 包的典型多线程服务端应用。</p><p>这里主要的性能目标是可伸缩性，即在大部分情况下，即使，或特别在同步器有竞争的情况下，稳定地保证其效率。在理想的情况下，不管有多少线程正试图通过同步点，通过同步点的开销都应该是个常量。在某一线程被允许通过同步点但还没有通过的情况下，使其耗费的总时间最少，这是主要目标之一。然而，这也必须考虑平衡各种资源，包括总 CPU 时间的需求，内存负载以及线程调度的开销。例如：获取自旋锁通常比阻塞锁所需的时间更短，但是通常也会浪费 CPU 时钟周期，并且造成内存竞争，所以使用的并不频繁。</p><p>实现同步器的这些目标包含了两种不同的使用类型。大部分应用程序是最大化其总的吞吐量，容错性，并且最好保证尽量减少饥饿的情况。然而，对于那些控制资源分配的程序来说，更重要是去维持多线程读取的公平性，可以接受较差的总吞吐量。没有任何框架可以代表用户去决定应该选择哪一个方式，因此，应该提供不同的公平策略。</p><p>无论同步器的内部实现是多么的精雕细琢，它还是会在某些应用中产生性能瓶颈。因此，框架必须提供相应的监视工具让用户发现和缓和这些瓶颈。至少需要提供一种方式来确定有多少线程被阻塞了。</p><h2 id="3-设计与实现">3 设计与实现</h2><p>同步器背后的基本思想非常简单。<code>acquire</code> 操作如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (synchronization state does not allow acquire) &#123;</span><br><span class="line">    enqueue current thread <span class="keyword">if</span> not already queued;</span><br><span class="line">    possibly block current thread;</span><br><span class="line">&#125;</span><br><span class="line">dequeue current thread <span class="keyword">if</span> it was queued;</span><br></pre></td></tr></table></figure><p><code>release</code> 操作如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update synchronization state;</span><br><span class="line"><span class="keyword">if</span> (state may permit a blocked thread to acquire)</span><br><span class="line">    unblock one or more queued threads;</span><br></pre></td></tr></table></figure><p>为了实现上述操作，需要下面三个基本组件的相互协作：</p><ul><li>同步状态的原子性管理</li><li>线程的阻塞与解除阻塞</li><li>队列的管理</li></ul><p>创建一个框架分别实现这三个组件是有可能的。但是，这会让整个框架既难用又没效率。例如：存储在队列节点的信息必须与解除阻塞所需要的信息一致，而暴露出的方法的签名必须依赖于同步状态的特性。</p><p>同步器框架的核心决策是为这三个组件选择一个具体实现，同时在使用方式上又有大量选项可用。这里有意地限制了其适用范围，但是提供了足够的效率，使得实际上没有理由在合适的情况下不用这个框架而去重新建造一个。</p><h3 id="3-1-同步状态">3.1 同步状态</h3><p>AQS 类使用单个 int（32位）来保存同步状态，并暴露出 <code>getState</code>、<code>setState</code> 以及 <code>compareAndSet</code> 操作来读取和更新这个状态。这些方法都依赖于 j.u.c atomic 包的支持，这个包提供了兼容 JSR133 中 <code>volatile</code> 在读和写上的语义，并且通过使用本地的 <code>compare-and-swap</code> 或 <code>load-linked/store-conditional</code> 指令来实现 <code>compareAndSetState</code>，使得仅当同步状态拥有一个期望值的时候，才会被原子地设置成新值。</p><p>将同步状态限制为一个 32 位的整形是出于实践上的考量。虽然 JSR166 也提供了 64 位 long 字段的原子性操作，但这些操作在很多平台上还是使用内部锁的方式来模拟实现的，这会使同步器的性能可能不会很理想。当然，将来可能会有一个类是专门使用 64 位的状态的。然而现在就引入这么一个类到这个包里并不是一个很好的决定（译者注：JDK1.6 中已经包含 <code>java.util.concurrent.locks.AbstractQueuedLongSynchronizer</code> 类，即使用 long 形式维护同步状态的一个 <code>AbstractQueuedSynchronizer</code> 版本）。目前来说，32 位的状态对大多数应用程序都是足够的。在 j.u.c 包中，只有一个同步器类可能需要多于 32 位来维持状态，那就是 <code>CyclicBarrier</code> 类，所以，它用了锁（该包中大多数更高层次的工具亦是如此）。</p><p>基于 AQS 的具体实现类必须根据暴露出的状态相关的方法定义 <code>tryAcquire</code> 和 <code>tryRelease</code> 方法，以控制 <code>acquire</code> 和 <code>release</code> 操作。当同步状态满足时，<code>tryAcquire</code> 方法必须返回 true，而当新的同步状态允许后续 <code>acquire</code> 时，<code>tryRelease</code> 方法也必须返回 true。这些方法都接受一个 int 类型的参数用于传递想要的状态。例如：可重入锁中，当某个线程从条件等待中返回，然后重新获取锁时，为了重新建立循环计数的场景。很多同步器并不需要这样一个参数，因此忽略它即可。</p><h3 id="3-2-阻塞">3.2 阻塞</h3><p>在 JSR166 之前，阻塞线程和解除线程阻塞都是基于 Java 内置监视器，没有基于 Java API 可以用来创建同步器。唯一可以选择的是 <code>Thread.suspend</code> 和 <code>Thread.resume</code>，但是它们都有无法解决的竞态问题，所以也没法用：当一个非阻塞的线程在一个正准备阻塞的线程调用 <code>suspend</code> 前调用了 <code>resume</code>，这个 <code>resume</code> 操作将不会有什么效果。</p><p>j.u.c 包有一个 <code>LockSuport</code> 类，这个类中包含了解决这个问题的方法。方法 <code>LockSupport.park</code> 阻塞当前线程除非/直到有个 <code>LockSupport.unpark</code> 方法被调用（unpark 方法被提前调用也是可以的）。unpark的调用是没有被计数的，因此在一个park调用前多次调用 unpark 方法只会解除一个 park 操作。另外，它们作用于每个线程而不是每个同步器。一个线程在一个新的同步器上调用 park 操作可能会立即返回，因为在此之前可能有 “剩余的” unpark 操作。但是，在缺少一个 unpark 操作时，下一次调用 park 就会阻塞。虽然可以显式地消除这个状态（译者注：就是多余的 unpark 调用），但并不值得这样做。在需要的时候多次调用 park 会更高效。</p><p>这个简单的机制与有些用法在某种程度上是相似的，例如 Solaris-9 的线程库，WIN32 中的“可消费事件”，以及 Linux 中的 NPTL 线程库。因此最常见的运行 Java 的平台上都有相对应的有效实现。（但目前 Solaris 和 Linux 上的 Sun Hotspot JVM 参考实现实际上是使用一个 pthread 的 condvar 来适应目前的运行时设计的）。park 方法同样支持可选的相对或绝对的超时设置，以及与 JVM 的 <code>Thread.interrupt</code> 结合 —— 可通过中断来 unpark 一个线程。</p><h3 id="3-3-队列">3.3 队列</h3><p>整个框架的关键就是如何管理被阻塞的线程的队列，该队列是严格的 FIFO 队列，因此，框架不支持基于优先级的同步。</p><p>同步队列的最佳选择是自身没有使用底层锁来构造的非阻塞数据结构，目前，业界对此很少有争议。而其中主要有两个选择：一个是 Mellor-Crummey 和 Scott 锁（MCS锁）[^9] 的变体，另一个是 Craig，Landin 和Hagersten 锁（CLH锁）[<sup>5][</sup>8][^10] 的变体。一直以来，<code>CLH</code> 锁仅被用于自旋锁。但是，在这个框架中，<code>CLH</code> 锁显然比 <code>MCS</code> 锁更合适。因为CLH锁可以更容易地去实现 “取消（cancellation）” 和 “超时” 功能，因此我们选择了 <code>CLH</code> 锁作为实现的基础。但是最终的设计已经与原来的 <code>CLH</code> 锁有较大的出入，因此下文将对此做出解释。</p><p><code>CLH</code> 队列实际上并不那么像队列，因为它的入队和出队操作都与它的用途（即用作锁）紧密相关。它是一个链表队列，通过两个字段 <code>head</code> 和 <code>tail</code> 来存取，这两个字段是可原子更新的，两者在初始化时都指向了一个空节点。</p><p><img src="http://ifeve.com/wp-content/uploads/2013/01/CLHNode.png" alt=""></p><p>一个新的节点 <code>node</code> 通过一个原子操作入队：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    pred = tail;</span><br><span class="line">&#125; <span class="keyword">while</span>(!tail.compareAndSet(pred, node));</span><br></pre></td></tr></table></figure><p>每一个节点的 “释放” 状态都保存在其前驱节点中。因此，自旋锁的 “自旋” 操作就如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (pred.status != RELEASED); <span class="comment">// spin</span></span><br></pre></td></tr></table></figure><p>自旋后的出队操作只需将 <code>head</code> 字段指向刚刚得到锁的节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head = node;</span><br></pre></td></tr></table></figure><p><code>CLH</code> 锁的优点在于其入队和出队操作是快速、无锁的，以及无障碍的（即使在竞争下，某个线程总会赢得一次插入机会而能继续执行）；且探测是否有线程正在等待也很快（只要测试一下 head 是否与 tail 相等）；同时，“释放” 状态是分散的（译者注：几乎每个节点都保存了这个状态，当前节点保存了其后驱节点的 “释放” 状态，因此它们是分散的，不是集中于一块的。），避免了一些不必要的内存竞争。</p><p>在原始版本的 <code>CLH</code> 锁中，节点间甚至都没有互相链接。自旋锁中，<code>pred</code> 变量可以是一个局部变量。然而，<code>Scott</code> 和 <code>Scherer</code> 证明了通过在节点中显式地维护前驱节点，<code>CLH</code> 锁就可以处理 “超时” 和各种形式的 “取消”：如果一个节点的前驱节点取消了，这个节点就可以滑动去使用前面一个节点的状态字段。</p><p>为了将 <code>CLH</code> 队列用于阻塞式同步器，需要做些额外的修改以提供一种高效的方式定位某个节点的后继节点。在自旋锁中，一个节点只需要改变其状态，下一次自旋中其后继节点就能注意到这个改变，所以节点间的链接并不是必须的。但在阻塞式同步器中，一个节点需要显式地唤醒（unpark）其后继节点。</p><p>AQS 队列的节点包含一个 <code>next</code> 链接到它的后继节点。但是，由于没有针对双向链表节点的类似<code>compareAndSet</code> 的原子性无锁插入指令，因此这个next链接的设置并非作为原子性插入操作的一部分，而仅是在节点被插入后简单地赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pred.next = node;</span><br></pre></td></tr></table></figure><p><code>next</code> 链接仅是一种优化。如果通过某个节点的 <code>next</code> 字段发现其后继结点不存在（或看似被取消了），总是可以使用 <code>pred</code> 字段从尾部开始向前遍历来检查是否真的有后续节点。</p><p>第二个对 <code>CLH</code> 队列主要的修改是将每个节点都有的状态字段用于控制阻塞而非自旋。在同步器框架中，仅在线程调用具体子类中的 <code>tryAcquire</code> 方法返回 true 时，队列中的线程才能从 <code>acquire</code> 操作中返回；而单个 “released” 位是不够的。但仍然需要做些控制以确保当一个活动的线程位于队列头部时，仅允许其调用 <code>tryAcquire</code>；这时的 <code>acquire</code> 可能会失败，然后（重新）阻塞。这种情况不需要读取状态标识，因为可以通过检查当前节点的前驱是否为head来确定权限。与自旋锁不同，读取 <code>head</code> 以保证复制时不会有太多的内存竞争（there is not enough memory contention reading head to warrant replication.）。然而，“取消” 状态必须存在于状态字段中。</p><p>队列节点的状态字段也用于避免没有必要的 park 和 unpark 调用。虽然这些方法跟阻塞原语一样快，但在跨越 Java 和 JVM runtime 以及操作系统边界时仍有可避免的开销。在调用 park 前，线程设置一个“唤醒（signal me）”位，然后再一次检查同步和节点状态。一个释放的线程会清空其自身状态。这样线程就不必频繁地尝试阻塞，特别是在锁相关的类中，这样会浪费时间等待下一个符合条件的线程去申请锁，从而加剧其它竞争的影响。除非后继节点设置了“唤醒”位（译者注：源码中为-1），否则这也可避免正在release的线程去判断其后继节点。这反过来也消除了这些情形：除非“唤醒”与“取消”同时发生，否则必须遍历多个节点来处理一个似乎为null的next字段。</p><p>同步框架中使用的 CLH 锁的变体与其他语言中的相比，主要区别可能是同步框架中使用的 CLH 锁需要依赖垃圾回收管理节点的内存，这就避免了一些复杂性和开销。但是，即使依赖 GC 也仍然需要在确定链接字段不再需要时将其置为 null。这往往可以与出队操作一起完成。否则，无用的节点仍然可触及，它们就没法被回收。</p><p>其它一些更深入的微调，包括 CLH 队列首次遇到竞争时才需要的初始空节点的延迟初始化等，都可以在J2SE1.5的版本的源代码文档中找到相应的描述。</p><p>抛开这些细节，基本的 <code>acquire</code> 操作的最终实现的一般形式如下（互斥，非中断，无超时）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!tryAcquire(arg)) &#123;</span><br><span class="line">    node = create and enqueue <span class="keyword">new</span> <span class="title class_">node</span>;</span><br><span class="line">    pred = node<span class="string">&#x27;s effective predecessor;</span></span><br><span class="line"><span class="string">    while (pred is not head node || !tryAcquire(arg)) &#123;</span></span><br><span class="line"><span class="string">        if (pred&#x27;</span>s signal bit is set)</span><br><span class="line">            pard()</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            compareAndSet pred<span class="string">&#x27;s signal bit to true;</span></span><br><span class="line"><span class="string">        pred = node&#x27;</span>s effective predecessor;</span><br><span class="line">    &#125;</span><br><span class="line">    head = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>release操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tryRelease(arg) &amp;&amp; head node<span class="string">&#x27;s signal bit is set) &#123;</span></span><br><span class="line"><span class="string">    compareAndSet head&#x27;</span>s bit to <span class="literal">false</span>;</span><br><span class="line">    unpark head<span class="string">&#x27;s successor, if one exist</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><code>acquire</code> 操作的主循环次数依赖于具体实现类中 <code>tryAcquire</code> 的实现方式。另一方面，在没有 “取消” 操作的情况下，每一个组件的 <code>acquire</code> 和 <code>release</code> 都是一个 <code>O(1)</code> 的操作，忽略 park 中发生的所有操作系统线程调度。</p><p>支持 “取消” 操作主要是要在 <code>acquire</code> 循环里的 park 返回时检查中断或超时。由超时或中断而被取消等待的线程会设置其节点状态，然后unpark其后继节点。在有 “取消” 的情况下，判断其前驱节点和后继节点以及重置状态可能需要 <code>O(n)</code> 的遍历（n 是队列的长度）。由于 “取消” 操作，该线程再也不会被阻塞，节点的链接和状态字段可以被快速重建。</p><h3 id="3-4-条件队列">3.4 条件队列</h3><p>AQS 框架提供了一个 <code>ConditionObject</code> 类，给维护独占同步的类以及实现 <code>Lock</code> 接口的类使用。一个锁对象可以关联任意数目的条件对象，可以提供典型的管程风格的 <code>await</code>、<code>signal</code> 和 <code>signalAll</code> 操作，包括带有超时的，以及一些检测、监控的方法。</p><p>通过修正一些设计决策，<code>ConditionObject</code> 类有效地将条件（conditions）与其它同步操作结合到了一起。该类只支持 Java 风格的管程访问规则，这些规则中，仅当当前线程持有锁且要操作的条件（condition）属于该锁时，条件操作才是合法的（一些替代操作的讨论参考 [^4]）。这样，一个 <code>ConditionObject</code> 关联到一个 <code>ReentrantLock</code> 上就表现的跟内置的管程（通过 <code>Object.wait</code> 等）一样了。两者的不同仅仅在于方法的名称、额外的功能以及用户可以为每个锁声明多个条件。</p><p><code>ConditionObject</code> 使用了与同步器一样的内部队列节点。但是，是在一个单独的条件队列中维护这些节点的。<code>signal</code> 操作是通过将节点从条件队列转移到锁队列中来实现的，而没有必要在需要唤醒的线程重新获取到锁之前将其唤醒。</p><p>基本的 <code>await</code> 操作如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create and add <span class="keyword">new</span> <span class="title class_">node</span> to conditon queue;</span><br><span class="line">release lock;</span><br><span class="line">block until node is on lock queue;</span><br><span class="line">re-acquire lock;</span><br></pre></td></tr></table></figure><p>signal操作如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transfer the first node from condition queue to lock queue;</span><br></pre></td></tr></table></figure><p>因为只有在持有锁的时候才能执行这些操作，因此他们可以使用顺序链表队列操作来维护条件队列（在节点中用一个 <code>nextWaiter</code> 字段）。转移操作仅仅把第一个节点从条件队列中的链接解除，然后通过 CLH 插入操作将其插入到锁队列上。</p><p>实现这些操作主要复杂在，因超时或 <code>Thread.interrupt</code> 导致取消了条件等待时，该如何处理。“取消” 和 “唤醒” 几乎同时发生就会有竞态问题，最终的结果遵照内置管程相关的规范。JSR133 修订以后，就要求如果中断发生在 <code>signal</code> 操作之前，<code>await</code> 方法必须在重新获取到锁后，抛出 <code>InterruptedException</code>。但是，如果中断发生在 <code>signal</code> 后，<code>await</code> 必须返回且不抛异常，同时设置线程的中断状态。</p><p>为了维护适当的顺序，队列节点状态变量中的一个位记录了该节点是否已经（或正在）被转移。“唤醒” 和 “取消” 相关的代码都会尝试用 <code>compareAndSet</code> 修改这个状态。如果某次 <code>signal</code> 操作修改失败，就会转移队列中的下一个节点（如果存在的话）。如果某次 “取消” 操作修改失败，就必须中止此次转移，然后等待重新获得锁。后面的情况采用了一个潜在的无限的自旋等待。在节点成功的被插到锁队列之前，被 “取消” 的等待不能重新获得锁，所以必须自旋等待 CLH 队列插入（即 <code>compareAndSet</code> 操作）被 “唤醒” 线程成功执行。这里极少需要自旋，且自旋里使用 <code>Thread.yield</code> 来提示应该调度某一其它线程，理想情况下就是执行 signal 的那个线程。虽然有可能在这里为 “取消” 实现一个帮助策略以帮助插入节点，但这种情况实在太少，找不到合适的理由来增加这些开销。在其它所有的情况下，这个基本的机制都不需要自旋或 <code>yield</code>，因此在单处理器上保持着合理的性能。</p><h2 id="4-用法">4 用法</h2><p>AQS 类将上述的功能结合到一起，并且作为一种基于 “模版方法模式” [^6] 的基类提供给同步器。子类只需定义状态的检查与更新相关的方法，这些方法控制着 <code>acquire</code> 和 <code>release</code> 操作。然而，将 AQS 的子类作为同步器 ADT 并不适合，因为这个类必须提供方法在内部控制 <code>acquire</code> 和 <code>release</code> 的规则，这些都不应该被用户所看到。所有 <code>java.util.concurrent</code> 包中的同步器类都声明了一个私有的继承了 <code>AbstractQueuedSynchronizer</code> 的内部类，并且把所有同步方法都委托给这个内部类。这样各个同步器类的公开方法就可以使用适合自己的名称。</p><p>下面是一个最简单的 <code>Mutex</code> 类的实现，它使用同步状态 0 表示解锁，1 表示锁定。这个类并不需要同步方法中的参数，因此这里在调用的时候使用 0 作为实参，方法实现里将其忽略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mutex</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> ignore)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> compareAndSetState(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> ignore)</span> &#123;</span><br><span class="line">            setState(<span class="number">0</span>); <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123; sync.acquire(<span class="number">0</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123; sync.release(<span class="number">0</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子的一个更完整的版本，以及其它用法指南，可以在J2SE的文档中找到。还可以有一些变体。如，<code>tryAcquire</code> 可以使用一种 “test-and-test-and-set” 策略，即在改变状态值前先对状态进行校验。</p><p>令人诧异的是，像互斥锁这样性能敏感的东西也打算通过委托和虚方法结合的方式来定义。然而，这正是现代动态编译器一直在重点研究的面向对象设计结构。编译器擅长将这方面的开销优化掉，起码会优化频繁调用同步器的那些代码。</p><p><code>AbstractQueuedSynchronizer</code> 类也提供了一些方法用来协助策略控制。例如，基础的 <code>acquire</code> 方法有可超时和可中断的版本。虽然到目前为止，我们的讨论都集中在像锁这样的独占模式的同步器上，但<code>AbstractQueuedSynchronizer</code> 类也包含另一组方法（如 acquireShared），它们的不同点在于 <code>tryAcquireShared</code> 和 <code>tryReleaseShared</code> 方法能够告知框架（通过它们的返回值）尚能接受更多的请求，最终框架会通过级联的 signal(cascading signals) 唤醒多个线程。</p><p>虽然将同步器序列化（持久化存储或传输）一般来说没有太大意义，但这些类经常会被用于构造其它类，例如线程安全的集合，而这些集合通常是可序列化的。<code>AbstractQueuedSynchronizer</code> 和 <code>ConditionObject</code> 类都提供了方法用于序列化同步状态，但不会序列化潜在的被阻塞的线程，也不会序列化其它内部暂时性的簿记（bookkeeping）变量。即使如此，在反序列化时，大部分同步器类也只仅将同步状态重置为初始值，这与内置锁的隐式策略一致 —— 总是反序列化到一个解锁状态。这相当于一个空操作，但仍必须显式地支持以便final字段能够反序列化。</p><h3 id="4-1-公平调度的控制">4.1 公平调度的控制</h3><p>尽管同步器是基于 FIFO 队列的，但它们并不一定就得是公平的。可以注意到，在基础的 acquire 算法（3.3节）中，<code>tryAcquire</code> 是在入队前被执行的。因此一个新的 <code>acquire</code> 线程能够“窃取”本该属于队列头部第一个线程通过同步器的机会。</p><p>可闯入的 FIFO 策略通常会提供比其它技术更高的总吞吐率。当一个有竞争的锁已经空闲，而下一个准备获取锁的线程又正在解除阻塞的过程中，这时就没有线程可以获取到这个锁，如果使用闯入策略，则可减少这之间的时间间隔。与此同时，这种策略还可避免过分的，无效率的竞争，这种竞争是由于只允许一个（第一个）排队的线程被唤醒然后尝试 <code>acquire</code> 操作导致的。在只要求短时间持有同步器的场景中，创建同步器的开发者可以通过定义 <code>tryAcquire</code> 在控制权返回之前重复调用自己若干次，来进一步凸显闯入的效果。</p><p><img src="http://ifeve.com/wp-content/uploads/2013/01/fifo-300x90.png" alt=""></p><p>可闯入的 FIFO 同步器只有概率性的公平属性。锁队列头部一个解除了阻塞的线程拥有一次无偏向的机会（译者注：即不会偏向队头的线程也不会偏向闯入的线程）来赢得与闯入的线程之间的竞争，如果竞争失败，要么重新阻塞要么进行重试。然而，如果闯入的线程到达的速度比队头的线程解除阻塞快，那么在队列中的第一个线程将很难赢得竞争，以至于几乎总要重新阻塞，并且它的后继节点也会一直保持阻塞。对于短暂持有的同步器来说，在队列中第一个线程被解除阻塞期间，多处理器上很可能发生过多次闯入（译者注：即闯入的线程的 acquire 操作）和 <code>release</code> 了。正如下文所提到的，最终结果就是保持一或多个线程的高进展速度的同时，仍至少在一定概率上避免了饥饿的发生。</p><p>当有更高的公平性需求时，实现起来也很简单。如果需要严格的公平性，程序员可以把 <code>tryAcquire</code> 方法定义为，若当前线程不是队列的头节点（可通过 <code>getFirstQueuedThread</code> 方法检查，这是框架提供的为数不多的几个检测方法之一），则立即失败（返回false）。</p><p>一个更快，但非严格公平的变体可以这样做，若队列为空（判断的瞬间），仍然允许 <code>tryAcquire</code> 执行成功。在这种情况下，多个线程同时遇到一个空队列时可能会去竞争以使自己第一个获得锁，这样，通常至少有一个线程是无需入队列的。<code>java.util.concurrent</code> 包中所有支持公平模式的同步器都采用了这种策略。</p><p>尽管公平性设置在实践中很有用，但是它们并没有保障，因为 Java Language Specification 没有提供这样的调度保证。例如：即使是严格公平的同步器，如果一组线程永远不需要阻塞来达到互相等待，那么 JVM 可能会决定纯粹以顺序方式运行它们。在实际中，单处理器上，在抢占式上下文切换之前，这样的线程有可能是各自运行了一段时间。如果这样一个线程正持有某个互斥锁，它将很快会被切换回来，仅是为了释放其持有的锁，然后会继续阻塞，因为它知道有另外一个线程需要这把锁，这更增加了同步器可用但没有线程能来获取之间的间隔。同步器公平性设置在多处理器上的影响可能会更大，因为在这种环境下会产生更多的交错，因此一个线程就会有更多的机会发现锁被另一个线程请求。</p><p>在高竞争下，当保护的是短暂持有锁的代码体时，尽管性能可能会较差，但公平锁仍然能有效地工作。例如，当公平性锁保护的是相对长的代码体和/或有着相对长的锁间(inter-lock)间隔，在这种情况下，闯入只能带来很小的性能优势，但却可能会大大增加无限等待的风险。同步器框架将这些工程决策留给用户来确定。</p><h3 id="4-2-同步器">4.2 同步器</h3><p>下面是 <code>java.util.concurrent</code> 包中同步器定义方式的概述：</p><p><code>ReentrantLock</code> 类使用 AQS 同步状态来保存锁（重复）持有的次数。当锁被一个线程获取时，<code>ReentrantLock</code> 也会记录下当前获得锁的线程标识，以便检查是否是重复获取，以及当错误的线程（译者注：如果线程不是锁的持有者，在此线程中执行该锁的 unlock 操作就是非法的）试图进行解锁操作时检测是否存在非法状态异常。<code>ReentrantLock</code> 也使用了 AQS 提供的 <code>ConditionObject</code>，还向外暴露了其它监控和监测相关的方法。<code>ReentrantLock</code> 通过在内部声明两个不同的 <code>AbstractQueuedSynchronizer</code> 实现类（提供公平模式的那个禁用了闯入策略）来实现可选的公平模式，在创建 <code>ReentrantLock</code> 实例的时候根据设置（译者注：即 ReentrantLock 构造方法中的 fair 参数）使用相应的 <code>AbstractQueuedSynchronizer</code> 实现类。</p><p><code>ReentrantReadWriteLock</code> 类使用 AQS 同步状态中的 16 位来保存写锁持有的次数，剩下的 16 位用来保存读锁的持有次数。<code>WriteLock</code> 的构建方式同 <code>ReentrantLock</code>。<code>ReadLock</code> 则通过使用 <code>acquireShared</code> 方法来支持同时允许多个读线程。</p><p><code>Semaphore</code> 类（计数信号量）使用 AQS 同步状态来保存信号量的当前计数。它里面定义的 <code>acquireShared</code> 方法会减少计数，或当计数为非正值时阻塞线程；<code>tryRelease</code> 方法会增加计数，可能在计数为正值时还要解除线程的阻塞。</p><p><code>CountDownLatch</code> 类使用 AQS 同步状态来表示计数。当该计数为 0 时，所有的 acquire 操作（译者注：acquire 操作是从 aqs 的角度说的，对应到 <code>CountDownLatch</code> 中就是 await 方法）才能通过。</p><p><code>FutureTask</code> 类使用 AQS 同步状态来表示某个异步计算任务的运行状态（初始化、运行中、被取消和完成）。设置（译者注：FutureTask 的 set 方法）或取消（译者注：FutureTask 的 cancel 方法）一个 <code>FutureTask</code> 时会调用 AQS 的 release 操作，等待计算结果的线程的阻塞解除是通过 AQS 的 <code>acquire</code> 操作实现的。</p><p><code>SynchronousQueues</code> 类（一种 CSP（Communicating Sequential Processes）形式的传递）使用了内部的等待节点，这些节点可以用于协调生产者和消费者。同时，它使用 AQS 同步状态来控制当某个消费者消费当前一项时，允许一个生产者继续生产，反之亦然。</p><p><code>java.util.concurrent</code> 包的使用者当然也可以为自定义的应用定义自己的同步器。例如，那些曾考虑到过的，但没有采纳进这个包的同步器包括提供WIN32事件各种风格的语义类，二元信号量，集中管理的锁以及基于树的屏障。</p><h2 id="5-性能">5 性能</h2><p>虽然 AQS 框架除了支持互斥锁外，还支持其它形式的同步方式，但锁的性能是最容易测量和比较的。即使如此，也还存在许多不同的测量方式。这里的实验主要是设计来展示锁的开销和吞吐量。</p><p>在每个测试中，所有线程都重复的更新一个伪随机数，该随机数由 <code>nextRandom(int seed)</code> 方法计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> (seed % <span class="number">127773</span>) * <span class="number">16807</span> - (seed / <span class="number">127773</span>) * <span class="number">2836</span>;</span><br><span class="line"><span class="keyword">return</span> (t &gt; <span class="number">0</span>) ? t : t + <span class="number">0x7fffffff</span>;</span><br></pre></td></tr></table></figure><p>在每次迭代中，线程以概率S在一个互斥锁下更新共享的生成器，否则（译者注：概率为 1-S）更新其自己局部的生成器，此时是不需要锁的。如此，锁占用区域的耗时是短暂的，这就使线程持有锁期间被抢占时的外界干扰降到了最小。这个函数的随机性主要是为了两个目的：确定是否需要使用锁（这个生成器足以应付这里的需求），以及使循环中的代码不可能被轻易地优化掉。</p><p>这里比较了四种锁：内置锁，用的是 <code>synchronized</code> 块；互斥锁，用的是像第四节例子中的那样简单的 <code>Mutex</code> 类；可重入锁，用的是 <code>ReentrantLock</code>；以及公平锁，用的是 <code>ReentrantLock</code> 的公平模式。所有测试都运行在 J2SE1.5 JDK build46（大致与 beta2 相同）的 server 模式下。在收集测试数据前，测试程序先运行 20 次非竞争的测试，以排除 JVM “预热”（译者注：更多关于 “预热” 的内容，参见：Java 理论与实践: 动态编译与性能测量）过程的影响。除了公平模式下的测试只跑了一百万次迭代，其它每个线程中的测试都运行了一千万次迭代。</p><p>该测试运行在四个 <code>x86</code> 机器和四个 <code>UltraSparc</code> 机器上。所有 <code>x86</code> 机器都运行的是 RedHat 基于 NPTL 2.4 内核和库的 Linux 系统。所有的 <code>UltraSparc</code> 机器都运行的是 <code>Solaris-9</code>。测试时所有系统的负载都很轻。根据该测试的特征，并不要求系统完全空闲（译者注：即测试时操作系统上有其它较轻的负载也不会影响本次测试的结果。）。“4P” 这个名字反映出双核超线程的Xeon更像是4路机器，而不是2路机器。这里没有将测试数据规范化。如下所示，同步的相对开销与处理器的数量、类型、速度之间不具备简单的关系。</p><table><thead><tr><th>名字</th><th>处理器数量</th><th>类型</th><th>速度(Mhz)</th></tr></thead><tbody><tr><td>1P</td><td>1</td><td>Pentium3</td><td>900</td></tr><tr><td>2P</td><td>2</td><td>Pentium3</td><td>1400</td></tr><tr><td>2A</td><td>2</td><td>Athlon</td><td>2000</td></tr><tr><td>4P</td><td>2HT</td><td>Pentium4/Xeon</td><td>2400</td></tr><tr><td>1U</td><td>1</td><td>UltraSparc2</td><td>650</td></tr><tr><td>4U</td><td>4</td><td>UltraSparc2</td><td>450</td></tr><tr><td>8U</td><td>8</td><td>UltraSparc3</td><td>750</td></tr><tr><td>24U</td><td>24</td><td>UltraSparc3</td><td>750</td></tr></tbody></table><p><strong>表1 测试的平台</strong></p><h3 id="5-1-开销">5.1 开销</h3><p>无竞争情况下的开销是通过仅运行一个线程，将概率 <code>S</code> 为 1 时的每次迭代时间减去概率 <code>S</code> 为 0（访问共享内存的概率为 0）时的每次迭代时间得到的（译者注：这里的“概率S”即前文提到的 “概率 S”，概率为 0 时是没有锁操作的，概率为 1 时是每次都有锁操作，因此将概率为1时的耗时减去概率为 0 时的耗时就是整个锁操作的开销。）。表 2 以纳秒为单位显示了非竞争场景下每次锁操作的开销。<code>Mutex</code> 类最接近于框架的基本耗时，可重入锁的额外开销是记录当前所有者线程和错误检查的耗时，对于公平锁来说还包含开始时检查队列是否为空的耗时。</p><p>表格 2 也展示与内置锁的 “快速路径（fast path）” 对比，<code>tryAcquire</code> 的耗时。这里的差异主要反映出了各锁和机器中使用的不同的原子指令以及内存屏障的耗时。在多处理器上，这些指令常常是完全优于所有其它指令的。内置锁和同步器类之间的主要差别，显然是由于 Hotspot 锁在锁定和解锁时都使用了一次<code>compareAndSet</code>，而同步器的 acquire 操作使用了一次 <code>compareAndSet</code> ，但 release 操作用的是一次volatile写（即，多处理器上的一次内存屏障以及所有处理器上的重排序限制）。每个锁的绝对的和相对耗时因机器的不同而不同。</p><table><thead><tr><th>机器</th><th>内置</th><th>互斥</th><th>可重入</th><th>公平可重入</th></tr></thead><tbody><tr><td>1P</td><td>18</td><td>9</td><td>31</td><td>37</td></tr><tr><td>2P</td><td>58</td><td>71</td><td>77</td><td>81</td></tr><tr><td>2A</td><td>13</td><td>21</td><td>31</td><td>30</td></tr><tr><td>4P</td><td>116</td><td>95</td><td>109</td><td>117</td></tr><tr><td>1U</td><td>90</td><td>40</td><td>58</td><td>67</td></tr><tr><td>4U</td><td>122</td><td>82</td><td>100</td><td>115</td></tr><tr><td>8U</td><td>160</td><td>83</td><td>103</td><td>123</td></tr><tr><td>24U</td><td>161</td><td>84</td><td>108</td><td>119</td></tr></tbody></table><p><strong>表2 无竞争时的单锁开销（单位：纳秒）</strong></p><p>从另一个极端看，表 3 展示了概率 <code>S</code> 为 1，运行 256 个并发线程时产生了大规模的锁竞争下每个锁的开销。在完全饱和的情况下，可闯入的FIFO锁比内置锁的开销少了一个数量级（也就是更大的吞吐量），比公平锁更是少了两个数量级。这表现出即使有着极大的竞争，在维持线程进展方面可闯入FIFO策略的效率。</p><p>表3也说明了即使在内部开销比较低的情况下，公平锁的性能也完全是由上下文切换的时间所决定的。列出的时间大致上都与各平台上线程阻塞和解除线程阻塞的时间相称。</p><p>此外，后面增加的一个实验（仅使用机器 4P）表明，对于这里用到的短暂持有的锁，公平参数的设置在总差异中的影响很小。这里将线程终止时间间的差异记录成一个粗粒度的离散量数。在 4P 的机器上，公平锁的时间度量的标准差平均为 <code>0.7%</code>，可重入锁平均为 <code>6.0%</code>。作为对比，为模拟一个长时间持有锁的场景，测试中使每个线程在持有锁的情况下计算了16K次随机数。这时，总运行时间几乎是相同的（公平锁：9.79s，可重入锁：9.72s）。公平模式下的差异依然很小，标准差平均为 <code>0.1%</code>，而可重入锁上升到了平均 <code>29.5%</code>。</p><p>| 机器 | 内置 | 互斥 | 可重入 | 公平可重入 |<br>| 1P | 521 | 46 | 67 | 8327 |<br>| 2P | 930 | 108 | 132 | 14967 |<br>| 2A | 748 | 79 | 84 | 33910 |<br>| 4P | 1146 | 188 | 247 | 15328 |<br>| 1U | 879 | 153 | 177 | 41394 |<br>| 4U | 2590 | 347 | 368 | 30004 |<br>| 8U | 1274 | 157 | 174 | 31084 |<br>| 24U | 1983 | 160 | 182 | 32291 |</p><p><strong>表格3 饱和时的单锁开销（单位：纳秒）</strong></p><h3 id="5-2-吞吐量">5.2 吞吐量</h3><p>大部分同步器都是用于无竞争和极大竞争之间的。这可以用实验在两个方面进行检查，通过修改固定个线程的竞争概率，和/或通过往拥有固定竞争概率的线程集合里增加更多的线程。为了说明这些影响，测试运行在不同的竞争概率和不同的线程数目下，都用的是可重入锁。附图使用了一个 slowdown 度量标准。</p><p><img src="http://ifeve.com/wp-content/uploads/2013/02/formula-300x66.jpg" alt=""></p><p>这里，t是总运行时间，b是一个线程在没有竞争或同步下的基线时间，n 是线程数，p 是处理器数，<code>S</code> 是共享访问的比例（译者注：即前面的竞争概率 S）。计算结果是实际执行时间与理想执行时间（通常是无法得到的）的比率，理想执行时间是通过使用 Amdahl’s 法则计算出来的。理想时间模拟了一次没有同步开销，没有因锁争用而导致线程阻塞的执行过程。即使这样，在很低的竞争下，相比理想时间，有一些测试结果却表现出了很小的速度增长，大概是由于基线和测试之间的优化、流水线等方面有着轻微的差别。</p><p>图中用以 2 为底的对数为比例进行了缩放。例如，值为 1 表示实际时间是理想时间的两倍，4 表示慢 16 倍。使用对数就不需要依赖一个随意的基线时间（这里指的是计算随机数的时间），因此，基于不同底数计算的结果表现出的趋势应该是类似的。这些测试使用的竞争概率从 <code>1/128</code>（标识为 “0.008”）到 1，以 2 的幂为步长，线程的数量从 1 到 1024，以 2 的幂的一半为步长。</p><p>在单处理器（1P 和 1U）上，性能随着竞争的上升而下降，但不会随着线程数的增加而下降。多处理器在遭遇竞争时，性能下降的更快。根据多处理器相关的图表显示，开始出现的峰值处虽然只有几个线程的竞争，但相对性能通常却最差。这反映出了一个性能的过渡区域，在这里闯入的线程和被唤醒的线程都准备获取锁，这会让它们频繁的迫使对方阻塞。在大部分时候，过渡区域后面会紧接着一个平滑区域，因为此时几乎没有空闲的锁，所以会与单处理器上顺序执行的模式差不多；在多处理器机器上会较早进入平滑区域。例如，请注意，在满竞争（标识为“1.000”）下这些值表示，在处理器越少的机器上，会有更糟糕的相对速度下降。</p><p>根据这些结果，可以针对阻塞（park/unpark）做进一步调优以减少上下文切换和相关的开销，这会给本框架带来小但显著的提升。此外，在多处理器上为短时间持有的但高竞争的锁采用某种形式的适应性自旋，可以避免这里看到的一些波动，这对同步器类大有裨益。虽然在跨不同上下文时适应性自旋很难很好的工作，但可以使用本框架为遇到这类使用配置的特定应用构建一个自定义形式的锁。</p><p><img src="https://images2015.cnblogs.com/blog/584866/201707/584866-20170721153333433-1036091107.jpg" alt=""></p><p><img src="https://images2015.cnblogs.com/blog/584866/201707/584866-20170721153344933-80322669.jpg" alt=""></p><p><img src="https://images2015.cnblogs.com/blog/584866/201707/584866-20170721153353714-548675583.jpg" alt=""></p><p><img src="https://images2015.cnblogs.com/blog/584866/201707/584866-20170721153402620-2093158242.jpg" alt=""></p><h2 id="6-总结">6 总结</h2><p>本文撰写之时，<code>java.util.concurrent</code> 包中的同步器框架还太新所以还不能在实践中使用。因此在 J2SE 1.5 最终版本发布之前都很难看到其大范围的使用，并且，它的设计，API 实现以及性能肯定还有无法预料的后果。但是，此时，这个框架明显能胜任其基本的目标，即为创建新的同步器提供一个高效的基础。</p><h2 id="7-致谢">7 致谢</h2><p>Thanks to Dave Dice for countless ideas and advice during the development of this framework, to Mark Moir and Michael Scott for urging consideration of CLH queues, to David Holmes for critiquing early versions of the code and API, to Victor Luchangco and Bill Scherer for reviewing previous incarnations of the source code, and to the other members of the JSR166 Expert Group (Joe Bowbeer, Josh Bloch, Brian Goetz, David Holmes, and Tim Peierls) as well as Bill Pugh, for helping with design and specifications and commenting on drafts of this paper. Portions of this work were made possible by a DARPA PCES grant, NSF grant EIA-0080206 (for access to the 24way Sparc) and a Sun Collaborative Research Grant.</p><h1>参考文献</h1><ol><li><p>Agesen, O., D. Detlefs, A. Garthwaite, R. Knippel, Y. S.Ramakrishna, and D. White. An Efficient Meta-lock for Implementing Ubiquitous Synchronization. ACM OOPSLA Proceedings, 1999.</p></li><li><p>Andrews, G. Concurrent Programming. Wiley, 1991.</p></li><li><p>Bacon, D. Thin Locks: Featherweight Synchronization for Java. ACM PLDI Proceedings, 1998.</p></li><li><p>Buhr, P. M. Fortier, and M. Coffin. Monitor Classification,ACM Computing Surveys, March 1995.</p></li><li><p>Craig, T. S. Building FIFO and priority-queueing spin locks from atomic swap. Technical Report TR 93-02-02,Department of Computer Science, University of Washington, Feb. 1993.</p></li><li><p>Gamma, E., R. Helm, R. Johnson, and J. Vlissides. Design Patterns, Addison Wesley, 1996.</p></li><li><p>Holmes, D. Synchronisation Rings, PhD Thesis, Macquarie University, 1999.</p></li><li><p>Magnussen, P., A. Landin, and E. Hagersten. Queue locks on cache coherent multiprocessors. 8th Intl. Parallel Processing Symposium, Cancun, Mexico, Apr. 1994.</p></li><li><p>Mellor-Crummey, J.M., and M. L. Scott. Algorithms for Scalable Synchronization on Shared-Memory Multiprocessors. ACM Trans. on Computer Systems,February 1991</p></li><li><p>M. L. Scott and W N. Scherer III. Scalable Queue-Based Spin Locks with Timeout. 8th ACM Symp. on Principles and Practice of Parallel Programming, Snowbird, UT, June 2001.</p></li><li><p>Sun Microsystems. Multithreading in the Solaris Operating Environment. White paper available at <a href="http://wwws.sun.com/software/solaris/whitepapers.html">http://wwws.sun.com/software/solaris/whitepapers.html</a> 2002.</p></li><li><p>Zhang, H., S. Liang, and L. Bak. Monitor Conversion in a Multithreaded Computer System. United States Patent 6,691,304. 2004.</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;转载自：&lt;a href=&quot;https://www.cnblogs.com/dennyzhangdd/p/7218510.html&quot;&gt;https://www.cnblogs.com/dennyzhangdd/p/7218510.html&lt;/a&gt;&lt;/p</summary>
      
    
    
    
    <category term="Java" scheme="https://www.buzhidao.cc/categories/Java/"/>
    
    
    <category term="Java" scheme="https://www.buzhidao.cc/tags/Java/"/>
    
    <category term="juc" scheme="https://www.buzhidao.cc/tags/juc/"/>
    
    <category term="翻译" scheme="https://www.buzhidao.cc/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat运维脚本</title>
    <link href="https://www.buzhidao.cc/2021/03/16/Tomcat%E8%BF%90%E7%BB%B4%E8%84%9A%E6%9C%AC/"/>
    <id>https://www.buzhidao.cc/2021/03/16/Tomcat%E8%BF%90%E7%BB%B4%E8%84%9A%E6%9C%AC/</id>
    <published>2021-03-16T13:44:25.000Z</published>
    <updated>2025-06-12T02:00:43.934Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">BASE_HOME=/deveye/dsp</span><br><span class="line">SERVER_PORT=8960</span><br><span class="line"></span><br><span class="line"># set customer varibales</span><br><span class="line">ulimit -n 65535</span><br><span class="line">export JAVA_HOME=$BASE_HOME/opt/jdk</span><br><span class="line">export JAVA_OPTS=&quot;-server -Xms16000m -Xmx16000m -XX:PermSize=128m -XX:MaxPermSize=256m -Djava.security.egd=file:/dev/./urandom&quot;</span><br><span class="line"></span><br><span class="line">log () &#123;</span><br><span class="line">    echo &quot;========&gt;&gt; $1 &lt;&lt;========&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get_pid_by_port () &#123;</span><br><span class="line">    PID=$(netstat -anp | grep $1 | grep LISTEN | awk &#x27;&#123;printf $7&#125;&#x27; | cut -d/ -f1)</span><br><span class="line"></span><br><span class="line">    if [[ &quot;$PID&quot; != &quot;&quot; &amp;&amp; &quot;$&#123;PID:0:1&#125;&quot; != &quot;-&quot; ]] ; then</span><br><span class="line">        echo $PID</span><br><span class="line">    else</span><br><span class="line">        echo -1</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kill_by_port () &#123;</span><br><span class="line">    PID=$(get_pid_by_port $1)</span><br><span class="line"></span><br><span class="line">    echo &quot;[$1] pid: [$PID]&quot;</span><br><span class="line"></span><br><span class="line">    if [ &quot;$PID&quot; != &quot;-1&quot; ] ; then</span><br><span class="line">        kill -9 $PID</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">    &#x27;start&#x27; )</span><br><span class="line">        log &quot;cdi start ...&quot;</span><br><span class="line">        /deveye/opt/rsync-client/bin/rsync-dsp</span><br><span class="line">        $BASE_HOME/opt/tomcat/bin/startup.sh</span><br><span class="line">        log &quot;cdi start ok.&quot;</span><br><span class="line">        ;;</span><br><span class="line">    &#x27;stop&#x27; )</span><br><span class="line">        log &quot;cdi stop ...&quot;</span><br><span class="line">        kill_by_port $SERVER_PORT</span><br><span class="line">        sleep 1s</span><br><span class="line">        log &quot;cdi stop ok.&quot;</span><br><span class="line">        ;;</span><br><span class="line">    &#x27;restart&#x27; )</span><br><span class="line">        $0 stop</span><br><span class="line">        sleep 1s</span><br><span class="line">        $0 start</span><br><span class="line">        ;;</span><br><span class="line">    &#x27;cc&#x27; )</span><br><span class="line">        &gt; $BASE_HOME/opt/tomcat/logs/catalina.out</span><br><span class="line">        exit 1</span><br><span class="line">        ;;</span><br><span class="line">    &#x27;tc&#x27; )</span><br><span class="line">        tail -f $BASE_HOME/opt/tomcat/logs/catalina.out</span><br><span class="line">        exit 1</span><br><span class="line">        ;;</span><br><span class="line">    &#x27;vc&#x27; )</span><br><span class="line">        vim $BASE_HOME/opt/tomcat/logs/catalina.out</span><br><span class="line">        exit 1</span><br><span class="line">        ;;</span><br><span class="line">    * )</span><br><span class="line">        echo &quot;Usage: $0 [ start | stop | restart | cc | tc | vc ]&quot;</span><br><span class="line">        exit 1</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    <category term="Tomcat" scheme="https://www.buzhidao.cc/categories/Tomcat/"/>
    
    
    <category term="Tomcat" scheme="https://www.buzhidao.cc/tags/Tomcat/"/>
    
    <category term="运维" scheme="https://www.buzhidao.cc/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>MySQL常用命令</title>
    <link href="https://www.buzhidao.cc/2021/03/16/MySQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://www.buzhidao.cc/2021/03/16/MySQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2021-03-16T12:34:18.000Z</published>
    <updated>2025-06-12T02:00:43.933Z</updated>
    
    <content type="html"><![CDATA[<h3 id="创建表空间">创建表空间</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./mysql -uroot -p -hlocalhost -P3306</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE DATABASE cicro DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br><span class="line">mysql&gt; CREATE USER &#x27;cicrouser&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;cicropassword&#x27;;</span><br><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON cicro.* TO &#x27;cicrouser&#x27;@&#x27;%&#x27;;</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;创建表空间&quot;&gt;创建表空间&lt;/h3&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    <category term="MySQL" scheme="https://www.buzhidao.cc/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://www.buzhidao.cc/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Docker安装软件集合</title>
    <link href="https://www.buzhidao.cc/2021/03/16/Docker%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E9%9B%86%E5%90%88/"/>
    <id>https://www.buzhidao.cc/2021/03/16/Docker%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E9%9B%86%E5%90%88/</id>
    <published>2021-03-16T11:53:27.000Z</published>
    <updated>2025-06-12T02:00:43.932Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Docker安装Nginx">Docker安装Nginx</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx -p 8000:80 -d --privileged=true \ </span><br><span class="line">-v $PWD/log:/var/log/nginx \</span><br><span class="line">-v $PWD/html:/usr/share/nginx/html \</span><br><span class="line">-v $PWD/conf/conf.d:/etc/nginx/conf.d \</span><br><span class="line">-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf --restart=always nginx</span><br></pre></td></tr></table></figure><h3 id="Docker安装FTP">Docker安装FTP</h3><ol><li>docker search vsftpd #寻找vsftpd的镜像<br>#假如我们找到一个最多引用的，叫fauria/vsftpd</li><li>docker pull fauria/vsftpd #把镜像pull到本地</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 21:21 -p 20:20 -p 21100-21110:21100-21110 --name vsftpd \</span><br><span class="line">-v /opt/ftp_file:/home/vsftpd \</span><br><span class="line">-e FTP_USER=username \</span><br><span class="line">-e FTP_PASS=password \</span><br><span class="line">-e PASV_ADDRESS=xxx.xxx.xxx.xxx \</span><br><span class="line">-e PASV_MIN_PORT=21100 \ </span><br><span class="line">-e PASV_MAX_PORT=21110  --restart=always fauria/vsftpd</span><br></pre></td></tr></table></figure><p><code>-p</code>进行端口绑定映射<br><code>-v</code>进行文件目录的映射 FTP_UESR 和FTP_PASS如果设定了会在container里面的<br>/etc/vsftpd/virtual_users.txt<br><code>PASV_MIN_PORT</code>和<code>PASV_MAX_PORT</code>映射的是被动模式下端口使用范围<br><code>PASV_ADDRESS</code>指的的宿主机地址</p><p>1、我们先进入container里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -i -t vsftpd bash </span><br></pre></td></tr></table></figure><p>2、修改并生成虚拟用户模式下的用户db文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/vsftpd/virtual_users.txt #编辑配置文件写入用户跟密码</span><br></pre></td></tr></table></figure><p>假如我们添加了user用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/vsftpd/user #建立新用户文件夹 </span><br><span class="line">/usr/bin/db_load -T -t hash</span><br><span class="line"> -f /etc/vsftpd/virtual_users.txt /etc/vsftpd/virtual_users.db</span><br></pre></td></tr></table></figure><h3 id="Docker-配置阿里镜像">Docker 配置阿里镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker </span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27; &#123; &quot;registry-mirrors&quot;: [&quot;https://2g2ux2e3.mirror.aliyuncs.com&quot;] &#125; EOF </span><br><span class="line">sudo systemctl daemon-reload </span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Docker安装Nginx&quot;&gt;Docker安装Nginx&lt;/h3&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;</summary>
      
    
    
    
    <category term="docker" scheme="https://www.buzhidao.cc/categories/docker/"/>
    
    
    <category term="docker" scheme="https://www.buzhidao.cc/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>《刻意练习》：以学习编程为例</title>
    <link href="https://www.buzhidao.cc/2021/01/17/%E3%80%8A%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0%E3%80%8B%EF%BC%9A%E4%BB%A5%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B%E4%B8%BA%E4%BE%8B/"/>
    <id>https://www.buzhidao.cc/2021/01/17/%E3%80%8A%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0%E3%80%8B%EF%BC%9A%E4%BB%A5%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B%E4%B8%BA%E4%BE%8B/</id>
    <published>2021-01-17T11:07:59.000Z</published>
    <updated>2025-06-12T02:00:43.934Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载自: <a href="%E8%BD%AC%E8%BD%BD%E4%BA%8E:https://juejin.im/post/5c3ca16ff265da617573f9a4">https://juejin.im/post/5c3ca16ff265da617573f9a4</a></p></blockquote><p>《刻意练习》是一本神奇的魔法书，它用大量的事实案例和数据来证明了刻意练习能给一个人带来的巨大改变。更为难能可贵的是，它不仅仅只是介绍刻意练习的好处，还给读者介绍了刻意练习的方法和注意事项，可以说是干货满满的一本书。</p><p>本文想以“学习编程”为例，结合《刻意练习》这本书教给我们的方式方法，阐述如何通过刻意练习来提高自己的编程水平。</p><h3 id="关于练习">关于练习</h3><p>**不断重复只是“天真的练习”，无法带来进步。“正确的练习”需要好导师、有目标、有反馈。**所以如果想要提高编程水平，光靠一味闷着头努力写代码是不够的，有些人写了几年的CRUD，可能整体的技术水平还不及刚毕业的同学。</p><p>一个好的导师很难得，他不仅要自己在编程水平是有一定的成就，还应该具有一些教育方面的经验，才能更好的指导你。一般来说，大一点的公司都会有老人带新人的机制，可以利用这个来找一个比较好的前辈带一带。另外就是通过看书或看视频其实也是一种很不错的学习方式，写书和出视频的老师自然是具备上述条件的。</p><p>有目标指的是应该要有明确的目标，而不是一个宽泛的目标。比如“我要提高Java水平”明显就是一个宽泛的目标，无法量化。明确的目标应该是什么样子呢？比如，我要学习JVM的基础知识，我要学完23种设计模式等等。一个好的目标还应该是可分解的，有时间或成果量化的。比如，我需要在一个月内学习完Java多线程技术，第一周学习多线程模型，第二周学习多线程基本的类和接口，第三周阅读JDK里面关于多线程方面的工具类的源码，第四周写多线程案例Demo，最后产出一个Java多线程系列笔记或者博客。</p><p>有反馈指的是可以量化的反馈。比如写一篇技术博客，有多少阅读量，点赞量，评论量？写一个开源项目有多少star，做一个LeetCode有没有通过，耗时如何？</p><p>上述算是对“有目的的练习”的一个阐述。刻意练习是在有目的的练习基础上的。总结起来，有目的的练习应该具有以下四个特点：</p><p>1.有目的的练习具有定义明确的特定目标<br>2.有目的的练习是专注的<br>3.有目的的练习包含反馈<br>4.有目的的练习需要走出舒适区</p><p>对于任何类型的练习，这是一条基本的真理：<strong>如果你从来不迫使自己走出舒适区，便永远无法进步。</strong></p><h3 id="关于心理表征">关于心理表征</h3><p>《刻意练习》这本书用了大量的篇幅来介绍心理表征。作者认为，刻意练习的核心之一在于通过练习来创建大量的心理表征，然后再使用这些心理表征反过来帮助练习。</p><p>那心理表征到底是什么？</p><p>我认为**它是一个人学习某样东西的时候，自己心中形成的一个体系架构。**比如我们学习算法，就会形成一个关于算法的体系架构，也就是心理表征。而当我们再学习到Mysql的底层索引原理的时候，就会想到算法关于平衡树方面的知识；当我们学习JDK源码里关于集合框架的时候，就会想到链表、栈与队列、红黑树等等。</p><p>我们的知识形成了一个循环，学得越多，懂得越多。当我们积累了大量的知识以后，再学一样有关联的东西，就能快速学会。</p><h3 id="刻意练习">刻意练习</h3><p>刻意练习提倡“边干边学”，**它使人们熟悉练习的习惯，并思考如何练习。**这与我们学习编程的理念是一样的，几乎没有人会对你说：你只需要看书，看博客，看视频就能学会编程。有经验的前辈一般会告诉你，要有输入，也要有输出。学习了的东西，要通过写代码或者做笔记或者写博客的方式，让知识变成你自己的，更加牢固。</p><p>你通过写代码，不断地写代码来提高自己的编程水平，然后通过思考，反思来决定该如何写代码才能写得更好。</p><p>传统的方法也一直是先找出关于正确方法的信息，然后很大程度上让学生去运用那些知识。<strong>刻意练习则完全相反，它只聚焦于绩效和表现，以及怎样提高绩效和表现。</strong></p><p>编程也是一样，老板和上级其实真正在意的并不是你懂多少理论，而是你写得代码质量好不好，你能不能快速地实现他们需要的功能，能不能解决技术难题。</p><p><strong>你的代码写得比别人快，你的代码写得比别人漂亮，你能快速解决别人不能解决的难题，那你就牛逼。</strong></p><h3 id="关于专注与坚持">关于专注与坚持</h3><p>刻意练习里面有一个观点颠覆了我以前的认知。我一度认为，一个人能不能专注，能不能坚持做一件事，除了热爱，那必然是意志力越高的人越能专注和坚持。</p><p>然而刻意练习告诉我，**意志力根本不存在！**所谓意志力，其实是保持动机与专注的结果。</p><p>我们先来看看如何让自己保持专注，**不专注的练习是没有效果的。**刻意练习提供了一个观点，<strong>如果练习的时间更短，那就会有更好的注意力。</strong></p><p>对于这个观点我是绝对认同的。比如看书，如果想一次性看完一本书，那对于一般人来说绝对是非常困难的。但是如果把它拆成一章一章，每天看一点，那就会好很多。而在日常的工作中或者学习中，我们可以使用“番茄钟”来管理自己的时间与保持专注。这里不具体介绍番茄钟，有兴趣的同学自己去了解一下，亲测有用！一个番茄钟25分钟，不多不少刚刚好。</p><p>再来谈谈动机。对于一个程序员来说，动机是再明显不过的了：升职加薪变大佬。但有时候这个动机并不能转化为一种强有力的动力来促使我们去学习，去提高技术水平。而某些太强烈的动机（比如想跳槽）又很难持续保持。</p><p>《刻意练习》告诉我们，<strong>我们要保持动机，要么强化继续前行的理由，要么弱化停下脚步的理由。</strong></p><p>仍然以学习算法为例。要强化继续前行的理由，我们可以在学习到一定阶段给自己一些小的奖励，比如刷完100个算法题，给自己买个好的键盘或者耳机。还有来自朋友、同事、家人乃至默认人的鼓励也很重要。我在网上写博客分享给大家，如果读者的点赞或者好评，那也是非常能激励我们继续学习的！</p><p>而弱化停下脚步的理由。比如练习累了就合理休息一下，学习累了就暂时玩一下，如果觉得自己一个人学技术太孤独，就找一群小伙伴一起学习或者加入一个技术社区。目标要精心设置且合理，这样才能得到达到目标的成就感，不会因为达不到目标而气馁放弃。</p><p><strong>愿你以梦为马，剑指天涯。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;转载自: &lt;a href=&quot;%E8%BD%AC%E8%BD%BD%E4%BA%8E:https://juejin.im/post/5c3ca16ff265da617573f9a4&quot;&gt;https://juejin.im/post/5c3ca16ff2</summary>
      
    
    
    
    <category term="读书" scheme="https://www.buzhidao.cc/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="转载" scheme="https://www.buzhidao.cc/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Redis常用命令</title>
    <link href="https://www.buzhidao.cc/2020/10/28/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://www.buzhidao.cc/2020/10/28/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2020-10-28T02:33:04.000Z</published>
    <updated>2025-06-12T02:00:43.934Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工作中常用到的Reids命令">工作中常用到的Reids命令</h3><ul><li>模糊匹配<em>key</em>并批量删除</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -u redis://password@ip:port/database keys &quot;business:data:10103*&quot; | xargs redis-cli -u redis://password@ip:port/database del</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;工作中常用到的Reids命令&quot;&gt;工作中常用到的Reids命令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;模糊匹配&lt;em&gt;key&lt;/em&gt;并批量删除&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    <category term="工作" scheme="https://www.buzhidao.cc/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="Redis" scheme="https://www.buzhidao.cc/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Git修改commit信息</title>
    <link href="https://www.buzhidao.cc/2020/10/23/Git%E4%BF%AE%E6%94%B9commit%E4%BF%A1%E6%81%AF/"/>
    <id>https://www.buzhidao.cc/2020/10/23/Git%E4%BF%AE%E6%94%B9commit%E4%BF%A1%E6%81%AF/</id>
    <published>2020-10-23T01:51:51.000Z</published>
    <updated>2025-06-12T02:00:43.933Z</updated>
    
    <content type="html"><![CDATA[<h4 id="修改commit信息主要有这几种情况">修改commit信息主要有这几种情况:</h4><ol><li>刚刚commit，还没有push，使用<code>git commit --amend</code></li><li>刚刚push，要修改最近一个push的commit信息，使用<code>git commit --amend</code></li><li>修改历史push的commit信息，使用<code>git rebase -i HEAD~n</code>【其中的n为记录数】，配合2中的命令</li></ol><blockquote><p><strong>注意：</strong><br>其中1、2两种情况的修改方式是一样的，但是git log的记录是不同的,第三种方式也是把需要修改的记录调整为最新的提交，然后使用2的方式修改。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;修改commit信息主要有这几种情况&quot;&gt;修改commit信息主要有这几种情况:&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;刚刚commit，还没有push，使用&lt;code&gt;git commit --amend&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;刚刚push，要修改最近一个push</summary>
      
    
    
    
    <category term="Git" scheme="https://www.buzhidao.cc/categories/Git/"/>
    
    
    <category term="Git" scheme="https://www.buzhidao.cc/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://www.buzhidao.cc/2020/09/27/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://www.buzhidao.cc/2020/09/27/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2020-09-27T07:52:43.000Z</published>
    <updated>2025-06-30T05:56:01.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="grep">grep</h2><p>查看配置文件只匹配不是以“#”开头的行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat .zshrc | grep -v &quot;^#&quot; &gt; profile.txt</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep -A 200 -B 20 &quot;BadSqlGrammarException&quot; ai-server.log</span><br><span class="line">grep -B 20 &quot;BadSqlGrammarException&quot; ai-server.log</span><br></pre></td></tr></table></figure><p>使用<code>tail</code>查看指定行以后的N行日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n +358653 catalina.2021-01-12.out|head -n 20</span><br></pre></td></tr></table></figure><h2 id="hash">hash</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hash 显示hash缓存</span><br><span class="line">hash –l 显示hash缓存，加参数-l既可以看到hash表命令的路径，也可以看到它的名字，说不定会有别名</span><br><span class="line">hash –p path name 将命令全路径path起别名为name</span><br><span class="line">hash –t name 显示指定命令的完整路径</span><br><span class="line">hash –d name 清除name缓存</span><br><span class="line">hash –r 清除缓存</span><br></pre></td></tr></table></figure><h2 id="awk">awk</h2><p>查询指定日志行数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;/error/&#123;print; for(i=1; i&lt;=10; i++) &#123;getline; print&#125;&#125;&#x27; ai-server.log</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;grep&quot;&gt;grep&lt;/h2&gt;
&lt;p&gt;查看配置文件只匹配不是以“#”开头的行&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.buzhidao.cc/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.buzhidao.cc/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>git commit之后，撤销commit</title>
    <link href="https://www.buzhidao.cc/2020/08/21/git-commit%E4%B9%8B%E5%90%8E-%E6%92%A4%E9%94%80commit/"/>
    <id>https://www.buzhidao.cc/2020/08/21/git-commit%E4%B9%8B%E5%90%8E-%E6%92%A4%E9%94%80commit/</id>
    <published>2020-08-21T02:26:11.000Z</published>
    <updated>2025-06-12T02:00:43.934Z</updated>
    
    <content type="html"><![CDATA[<h3 id="场景">场景</h3><p>一般情况下，我们写完代码后会执行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;xxx&quot;</span><br></pre></td></tr></table></figure><p>但是执行完后，想撤回怎么办？可以执行以下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD^</span><br></pre></td></tr></table></figure><p>这样就可以撤回你的提交，并且不会丢失提交前修改的内容.</p><h3 id="理解">理解</h3><p>HEAD^ 代表上一个版本，同等于HEAD<sub>1，如果进行了两次提交，可以写成HEAD</sub>2</p><p><strong>参数</strong></p><blockquote><p>--mixed</p></blockquote><p>默认参数，不删除工作空间改动的代码，只撤回提交，并且撤回<code>git add .</code>操作</p><blockquote><p>--soft</p></blockquote><p>不删除工作空间改动的代码，撤销提交，但是不撤回<code>git add .</code> 操作</p><blockquote><p>--hard</p></blockquote><p>删除工作空间改动的代码，撤销commit，撤销<code>git add .</code>，直接回退到上次<code>commit</code></p><h3 id="最后">最后</h3><p>如果commit注释写错了，只是想改一下注释，只需要：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>此时会进入默认vim编辑器，修改注释完毕后保存就好了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;场景&quot;&gt;场景&lt;/h3&gt;
&lt;p&gt;一般情况下，我们写完代码后会执行:&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/sp</summary>
      
    
    
    
    <category term="Git" scheme="https://www.buzhidao.cc/categories/Git/"/>
    
    
    <category term="Git" scheme="https://www.buzhidao.cc/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git rebase和git merge的区别</title>
    <link href="https://www.buzhidao.cc/2020/08/19/git-rebase%E5%92%8Cgit-merge%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://www.buzhidao.cc/2020/08/19/git-rebase%E5%92%8Cgit-merge%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-08-19T15:19:33.000Z</published>
    <updated>2025-06-12T02:00:43.934Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Description">Description</h3><p><code>git rebase</code> 和 <code>git merge</code> 一样都是用于从一个分支获取并且合并到当前分支，但是他们采取不同的工作方式，以下面的一个工作场景说明其区别.</p><p>如图所示：你在一个feature分支进行新特性的开发，与此同时，master 分支的也有新的提交。</p><p><img src="http://qiniu.deveye.cn/b454bf1d01ec3dee808830b24dd87c2e.png" alt="http://qiniu.deveye.cn/b454bf1d01ec3dee808830b24dd87c2e.png"><br>为了将master 上新的提交合并到你的feature分支上，你有两种选择：<code>merging or rebasing</code></p><h3 id="merge">merge</h3><p>执行以下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git merge master</span><br></pre></td></tr></table></figure><p>或者执行更简单的：<br><code>git merge master feature</code></p><p>那么此时在feature上git 自动会产生一个新的commit(merge commit)<br>look like this：</p><p><img src="http://qiniu.deveye.cn/2cebea59e5f82803cb35f99f85b6653d.png" alt="http://qiniu.deveye.cn/2cebea59e5f82803cb35f99f85b6653d.png"></p><p>**merge 特点：**自动创建一个新的commit,如果合并的时候遇到冲突，仅需要修改后重新commit<br>**优点：**记录了真实的commit情况，包括每个分支的详情<br>**缺点：**因为每次merge会自动产生一个merge commit，所以在使用一些git 的GUI tools，特别是commit比较频繁时，看到分支很杂乱。</p><h3 id="rebase">rebase</h3><p>本质是变基,执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure><p><img src="http://qiniu.deveye.cn/245938aba30e1d7ff14f759eea81eb37.png" alt="http://qiniu.deveye.cn/245938aba30e1d7ff14f759eea81eb37.png"><br>**rebase 特点：**会合并之前的commit历史<br>**优点：**得到更简洁的项目历史，去掉了merge commit<br>**缺点：**如果合并出现代码问题不容易定位，因为re-write了history<br>合并时如果出现冲突需要按照如下步骤解决</p><ul><li>修改冲突部分</li><li>git add</li><li>git rebase --continue</li><li>（如果第三步无效可以执行 git rebase --skip）</li></ul><p>不要在git add 之后习惯性的执行 git commit命令<br><em><strong>The Golden Rule of Rebasing rebase</strong></em> 的黄金法则:<br><strong>never use it on public branches(不要在公共分支上使用)</strong><br>比如说如下场景：如图所示<br><img src="http://qiniu.deveye.cn/ac37304e85f5ddf56f1fc302b9e42781.png" alt="http://qiniu.deveye.cn/ac37304e85f5ddf56f1fc302b9e42781.png"></p><p>如果你rebase master 到你的feature分支：<br>rebase 将所有master的commit移动到你的feature 的顶端。问题是：其他人还在original master上开发，由于你使用了rebase移动了master，git 会认为你的主分支的历史与其他人的有分歧，会产生冲突。<br>所以在执行git rebase 之前 问问自己，</p><p>会有其他人看这个分支么？<br>IF YES 不要采用这种带有破坏性的修改commit 历史的rebase命令<br>IF NO OK，随你便，可以使用rebase</p><h3 id="Summary-总结">Summary 总结</h3><p>如果你想要一个干净的，没有merge commit的线性历史树，那么你应该选择git rebase<br>如果你想保留完整的历史记录，并且想要避免重写commit history的风险，你应该选择使用git merge</p><h3 id="参考资料">参考资料</h3><blockquote><p><a href="https://www.atlassian.com/git/tutorials/merging-vs-rebasing/conceptual-overview">https://www.atlassian.com/git/tutorials/merging-vs-rebasing/conceptual-overview</a><br><a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA">https://git-scm.com/book/zh/v2/Git-分支-变基</a><br><a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6#_basic_merging">https://git-scm.com/book/zh/v2/Git-分支-分支的新建与合并#_basic_merging</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Description&quot;&gt;Description&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git rebase&lt;/code&gt; 和 &lt;code&gt;git merge&lt;/code&gt; 一样都是用于从一个分支获取并且合并到当前分支，但是他们采取不同的工作方式，以下面的一个工作场景说明其</summary>
      
    
    
    
    <category term="Git" scheme="https://www.buzhidao.cc/categories/Git/"/>
    
    
    <category term="Git" scheme="https://www.buzhidao.cc/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Nginx反向代理配置</title>
    <link href="https://www.buzhidao.cc/2020/08/19/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.buzhidao.cc/2020/08/19/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</id>
    <published>2020-08-19T05:47:59.000Z</published>
    <updated>2025-06-12T02:00:43.933Z</updated>
    
    <content type="html"><![CDATA[<p>使用nginx做反向代理的时候，可以简单的直接把请求原封不动的转发给下一个服务。设置<code>proxy_pass</code>请求只会替换域名，如果要根据不同的url后缀来访问不同的服务，则需要通过如下方法：</p><h3 id="方法一：加">方法一：加&quot;/&quot;</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen              8000;</span><br><span class="line">    server_name         abc.com;</span><br><span class="line">    access_log  &quot;pipe:rollback /data/log/nginx/access.log interval=1d baknum=7 maxsize=1G&quot;  main;</span><br><span class="line"></span><br><span class="line">    location ^~/user/ &#123;</span><br><span class="line">        proxy_set_header  Host $host;</span><br><span class="line">        proxy_set_header  X-Real-IP        $remote_addr;</span><br><span class="line">        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header  X-NginX-Proxy true;</span><br><span class="line"></span><br><span class="line">        proxy_pass http://user/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ^~/order/ &#123;</span><br><span class="line">        proxy_set_header  Host $host;</span><br><span class="line">        proxy_set_header  X-Real-IP        $remote_addr;</span><br><span class="line">        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header  X-NginX-Proxy true;</span><br><span class="line"></span><br><span class="line">        proxy_pass http://order/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>^~/user/表示匹配前缀是user的请求，proxy_pass的结尾有/， 则会把/user/*后面的路径直接拼接到后面，即移除user。</p><h3 id="方法二：rewrite">方法二：rewrite</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">location ^~/user/ &#123;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header  X-Real-IP        $remote_addr;</span><br><span class="line">        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-NginX-Proxy true;</span><br><span class="line"></span><br><span class="line">        rewrite ^/user/(.*)$ /$1 break;</span><br><span class="line">        proxy_pass http://user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ^~/order/ &#123;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header  X-Real-IP        $remote_addr;</span><br><span class="line">        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-NginX-Proxy true;</span><br><span class="line"></span><br><span class="line">        rewrite ^/order/(.*)$ /$1 break;</span><br><span class="line">        proxy_pass http://order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>proxy_pass结尾没有/， rewrite重写了url。</p><h3 id="location匹配命令">location匹配命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~     #波浪线表示执行一个正则匹配，区分大小写</span><br><span class="line">~*    #表示执行一个正则匹配，不区分大小写</span><br><span class="line">^~    #^~表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录</span><br><span class="line">=     #进行普通字符精确匹配</span><br><span class="line">@     #&quot;@&quot; 定义一个命名的 location，使用在内部定向时，例如 error_page, try_files</span><br></pre></td></tr></table></figure><h3 id="location-匹配的优先级-与location在配置文件中的顺序无关">location 匹配的优先级(与location在配置文件中的顺序无关)</h3><p><em><strong>=</strong></em> 精确匹配会第一个被处理。如果发现精确匹配，nginx停止搜索其他匹配。</p><p>普通字符匹配，正则表达式规则和长的块规则将被优先和查询匹配，也就是说如果该项匹配还需去看有没有正则表达式匹配和更长的匹配。</p><p><em><strong>^~</strong></em> 则只匹配该规则，nginx停止搜索其他匹配，否则nginx会继续处理其他location指令。</p><p>最后匹配理带有&quot;<sub>&quot;和&quot;</sub>*&quot;的指令，如果找到相应的匹配，则nginx停止搜索其他匹配；当没有正则表达式或者没有正则表达式被匹配的情况下，那么匹配程度最高的逐字匹配指令会被使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用nginx做反向代理的时候，可以简单的直接把请求原封不动的转发给下一个服务。设置&lt;code&gt;proxy_pass&lt;/code&gt;请求只会替换域名，如果要根据不同的url后缀来访问不同的服务，则需要通过如下方法：&lt;/p&gt;
&lt;h3 id=&quot;方法一：加&quot;&gt;方法一：加&amp;quot;</summary>
      
    
    
    
    <category term="Nginx" scheme="https://www.buzhidao.cc/categories/Nginx/"/>
    
    
    <category term="Nginx" scheme="https://www.buzhidao.cc/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Redis分布式锁</title>
    <link href="https://www.buzhidao.cc/2020/07/09/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>https://www.buzhidao.cc/2020/07/09/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2020-07-09T08:09:01.000Z</published>
    <updated>2025-06-12T02:00:43.933Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介">简介</h3><p>在一些分布式系统中，应用与应用之间是相互独立部署的，Java应用运行在不同的JVM中，所以，在操作一些共享资源的时候，使用JDK提供的Lock工具类时就有些力不从心，这时候就需要借助外力来实现分布式一致性问题。</p><p>通常会使用以下三种方式进行实现：</p><ul><li>基于数据库实现分布式锁(悲观锁机制)</li><li>Zookeeper分布式锁</li><li>Redis分布式锁</li></ul><p>下面简单对比几种方式的优缺点：</p><table><thead><tr><th>方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>数据库</td><td>实现简单、易于理解</td><td>对数据库压力大</td></tr><tr><td>Redis</td><td>易于理解</td><td>自己实现、不支持阻塞</td></tr><tr><td>Zookeeper</td><td>支持阻塞</td><td>需要理解Zookeeper、程序复杂</td></tr><tr><td>Curator</td><td>提供锁的方法</td><td>依赖Zookeeper、强一致</td></tr><tr><td>Redisson</td><td>提供锁的方法、可阻塞</td><td></td></tr></tbody></table><h3 id="安全和活性的保证">安全和活性的保证</h3><p>Redis官方文档提出以下三点作为分布式锁的最低保证：</p><ol><li><strong>互斥</strong>，在任何给定时刻，只有一个客户端可以持有锁</li><li><strong>无死锁</strong>，最终，即使锁定资源的客户端崩溃或分区，也始终可以获得锁</li><li><strong>容错能力</strong>，只要大多数Redis节点都处于运行状态，客户端就可以获取和释放锁</li></ol><h3 id="基于主备架构实现的不足">基于主备架构实现的不足</h3><p>使用Redis实现分布式锁最简单的方法就是加锁的时候创建一个带有过期时间Key(这样是为了防止出现死锁)，当客户端需要释放锁的时候删除这个Key。</p><p>从表面上看没有什么问题，但是当Redis出现宕机的时候怎么办？为了解决单点故障问题，我们可以添加一个从节点，当主节点不可用的时候，切换到从节点，但是这样实际上是不可行的，因为Redis使用的是异步复制。</p><p>该模型明显存在的竞争条件:</p><ol><li>客户端A获取主节点的锁</li><li>主节点将Key同步到从节点之前发生宕机</li><li>从节点切换成主节点</li><li>客户端B获取到相同资源的锁，此时A和B同时持有锁，<strong>违反了安全性</strong></li></ol><h3 id="单实例方案">单实例方案</h3><p>假设可以克服以上单节点不足的问题，我们可以使用以下命令实现分布式锁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET resource_name my_random_value NX PX 30000</span><br></pre></td></tr></table></figure><p>该命令仅在Key不存在(NX)、且到期时间(PX)为30000毫秒的情况下才设置Key。Key的值为一个随机数，该值要求必须全局唯一，使用全局唯一值是为了在删除Key的时候，Key的值是我们之前设置的值时，才删除Key。(Tips:<strong>我们总不能删除其他客户端设置的Key吧？</strong>)</p><p>可以使用以下Lua脚本完成，因为Lua脚本可以保证两个操作的原子性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then</span><br><span class="line">    return redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="RedLock算法">RedLock算法</h3><p>在算法的分布式版本中，我们假设有5个Master节点，这些节点是完全独立的，我们将各个节点部署在不同的服务器中，以保证他们同时出现故障的概率。</p><p>为了获取锁，客户端执行以下操作：</p><ol><li>客户端获取当前时间的时间戳</li><li>客户端尝试在N（N=5）个节点上以相同的Key和Value获取一个锁(此处和单实例方式相同)</li><li>客户端通过从当前时间中减去在步骤1中获得的时间戳，来计算获取锁所花费的时间，当客户端能够在大多数实例（至少3个）中获取锁时 ，并且获取锁所花费的总时间小于锁有效时间，则认为已获取锁。</li><li>如果获取了锁，则将其有效时间视为初始有效时间减去经过的时间</li><li>如果客户端由于某种原因（无法锁定N / 2 + 1实例或有效时间为负数）而未能获得该锁，它将尝试解锁所有实例</li></ol><h3 id="释放锁">释放锁</h3><p>释放锁很简单，只需在所有实例中释放锁（即使之前在某个实例中没有获取到锁）。</p><h3 id="RedLock注意点">RedLock注意点</h3><ol><li>先假设client获取所有实例，所有实例包含相同的key和过期时间(TTL) ,但每个实例set命令时间不同导致不能同时过期，第一个set命令之前是T1,最后一个set命令后为T2,则此client有效获取锁的最小时间为TTL-(T2-T1)-时钟漂移</li><li>对于以N/2+ 1(也就是一半以 上)的方式判断获取锁成功，是因为如果小于一半判断为成功的话，有可能出现多个client都成功获取锁的情况，从而使锁失效</li><li>一个client锁定大多数事例耗费的时间大于或接近锁的过期时间，就认为锁无效，并且解锁这个redis实例(不执行业务) ;只要在TTL时间内成功获取一半以上的锁便是有效锁;否则无效</li></ol><h3 id="系统具有活性的三大特征">系统具有活性的三大特征</h3><ol><li>能够自动释放锁</li><li>再获取锁失败（不到一半以上），或任务完成后能够释放锁，不用等到其自动过期</li><li>再客户端重试获取锁之前（第一次失败到第二次失败之间的间隔时间）大于获取锁消耗的时间</li></ol><blockquote><p>参考Redis官方文档 <a href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a><br>RedLock分析      [<a href="http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html</a>][<a href="http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html</a>]</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;在一些分布式系统中，应用与应用之间是相互独立部署的，Java应用运行在不同的JVM中，所以，在操作一些共享资源的时候，使用JDK提供的Lock工具类时就有些力不从心，这时候就需要借助外力来实现分布式一致性问题。&lt;/p&gt;
&lt;p&gt;通常会使</summary>
      
    
    
    
    <category term="Redis" scheme="https://www.buzhidao.cc/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://www.buzhidao.cc/tags/Redis/"/>
    
    <category term="分布式锁" scheme="https://www.buzhidao.cc/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Redis哨兵</title>
    <link href="https://www.buzhidao.cc/2020/07/07/Redis%E5%93%A8%E5%85%B5/"/>
    <id>https://www.buzhidao.cc/2020/07/07/Redis%E5%93%A8%E5%85%B5/</id>
    <published>2020-07-07T15:00:54.000Z</published>
    <updated>2025-06-12T02:00:43.933Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Sentinel的分布式特征">Sentinel的分布式特征</h3><p>Redis Sentinel是一个分布式系统：<br>Sentinel本身的设计是在为多个Sentinel进程协同合作的配置中运行。</p><ul><li>当多个哨兵就给定的主机不再可用的事实达成共识时，将执行故障检测，降低了误报的可能性。</li><li>即使不是所有的Sentinel进程都在工作，Sentinel仍可正常工作，从而使系统能够应对故障。毕竟，拥有故障转移系统本身就是一个单点故障，</li></ul><h3 id="运行哨兵">运行哨兵</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /path/to/sentinel.conf</span><br></pre></td></tr></table></figure><p><code>redis-sentinel</code>是<code>redis-server</code>的一个软链接，所以也可以使用以下方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /path/to/sentinel.conf --sentinel</span><br></pre></td></tr></table></figure><p>两种方法的工作原理相同。</p><p>但是，再运行<code>Sentinel</code>时<strong>必须</strong>指定配置文件，因为系统将使用此文件来保存当前状态，以便在重新启动时重新加载。如果未指定文件，则会启动失败。</p><p>Sentinels默认情况下会<strong>监听TCP端口26379连接</strong>，因此必须打开26379端口。</p><h3 id="Sentinel的基础知识">Sentinel的基础知识</h3><ol><li>一个健壮的集群至少需要三个Sentinel实例</li><li>应该将三个Sentinel实例部署在不同的机器上</li><li>因为Redis使用的是异步复制，所以不能保证在故障转移期间保证数据的写入。</li></ol><h3 id="配置哨兵">配置哨兵</h3><p>Redis的源码包包含一个sentinel.conf文件可用于配置Sentinel，典型的最小配置如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 60000</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br></pre></td></tr></table></figure><p>sentinel monitor含义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor &lt;master-group-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;master-group-name&gt;</code> 指主节点名称，<code>&lt;ip&gt;</code> IP地址 <code>&lt;port&gt;</code>端口号，重点说一下<code>&lt;quorum&gt;</code>：<br>假如有5个Sentinel进程，并且给定主服务器的quorum置为2，则将发生以下情况：</p><ul><li>如果有两个哨兵同时发现主节点不可访问，则其中一个哨兵将尝试启动故障转移。</li><li>如果有三个哨兵同时发现主节点不可访问，则将启动故障转移。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel down-after-milliseconds</span><br></pre></td></tr></table></figure><p><code>down-after-milliseconds</code>是指Sentinel在指定的时间内没有获得实例的响应，则认为实例已关闭。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel parallel-syncs</span><br></pre></td></tr></table></figure><p><code>parallel-syncs</code> 设置每次可以对几个副本进行同步数据</p><h3 id="Redis-哨兵部署示例">Redis 哨兵部署示例</h3><h4 id="经典三节点最小部署">经典三节点最小部署</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        +----+</span><br><span class="line">        | M1 |</span><br><span class="line">        | S1 |</span><br><span class="line">        +----+</span><br><span class="line">           |</span><br><span class="line"> +----+    |    +----+</span><br><span class="line"> | R2 |----+----| R3 |</span><br><span class="line"> | S2 |         | S3 |</span><br><span class="line"> +----+         +----+</span><br><span class="line"></span><br><span class="line">Configuration: quorum = 2</span><br></pre></td></tr></table></figure><p>如果主M1发生故障，则S2和S3将达成协议，并能够开启故障转移，从而使客户端能够继续使用。</p><h4 id="模拟发生网络分区">模拟发生网络分区</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">         +----+</span><br><span class="line">         | M1 |</span><br><span class="line">         | S1 | &lt;- C1 (writes will be lost)</span><br><span class="line">         +----+</span><br><span class="line">            |</span><br><span class="line">            /</span><br><span class="line">            /</span><br><span class="line">+------+    |    +----+</span><br><span class="line">| [M2] |----+----| R3 |</span><br><span class="line">| S2   |         | S3 |</span><br><span class="line">+------+         +----+</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这种情况下，网络分区隔离了旧的主数据库M1，因此副本R2被提升为主数据库。但是，与旧主服务器位于同一分区中的客户端（例如C1）可能会继续向旧主服务器写入数据。该数据将永远丢失，因为当分区恢复正常时，主服务器将被重新配置为新主服务器的副本，从而造成数据丢失。</p><p>使用以下Redis复制功能可以缓解此问题，如果主服务器检测到副本数量没有达到指定的副本数据，则停止接受数据写入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 最小副本数量</span><br><span class="line">min-replicas-to-write 1</span><br><span class="line"># 发送异步确认的最大时间</span><br><span class="line">min-replicas-max-lag 10</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Sentinel的分布式特征&quot;&gt;Sentinel的分布式特征&lt;/h3&gt;
&lt;p&gt;Redis Sentinel是一个分布式系统：&lt;br&gt;
Sentinel本身的设计是在为多个Sentinel进程协同合作的配置中运行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当多个哨兵就给定的主机不</summary>
      
    
    
    
    <category term="Redis" scheme="https://www.buzhidao.cc/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://www.buzhidao.cc/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件选型</title>
    <link href="https://www.buzhidao.cc/2020/05/14/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%80%89%E5%9E%8B/"/>
    <id>https://www.buzhidao.cc/2020/05/14/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%80%89%E5%9E%8B/</id>
    <published>2020-05-14T08:18:19.000Z</published>
    <updated>2025-06-12T02:00:43.935Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文主要对比常用的三种中间件优劣势，包含RocketMQ、Kafka、RabbitMQ。</strong></p><h2 id="Kafka">Kafka</h2><h4 id="优势">优势</h4><ul><li>Kafka的吞吐量几乎是行业里最优秀的，在常规的机器配置下，一台机器可以达到每秒十几万的QPS，相当的强悍。</li><li>Kafka性能也很高，基本上发送消息给Kafka都是毫秒级的性能。可用性也很高，Kafka是可以支持集群部署的，其中部分机器宕机是可以继续运行的。</li><li>Kafka技术在各大公司里的使用，基本行业里的一个标准，是把Kafka用在用户行为日志的采集和传输上，比如大数据团队要收集APP上用户的一些行为日志，这种日志就是用Kafka来收集和传输的。</li></ul><h4 id="劣势">劣势</h4><ul><li>Kafka比较为人诟病的一点，似乎是丢数据方面的问题，因为Kafka收到消息之后会写入一个磁盘缓冲区里，并没有直接落地到物理磁盘上去，所以要是机器本身故障了，可能会导致磁盘缓冲区里的数据丢失。</li><li>Kafka另外一个比较大的缺点，就是功能非常的单一，主要是支持发送消息给他，然后从里面消费消息，其他就没有什么额外的高级功能了。所以基于Kafka有限的功能，可能适用的场景并不是很多。</li></ul><h4 id="总结">总结</h4><p>Kafka适用于那种日志适当丢失数据是没有关系的，而且一般量特别大，要求吞吐量要高，一般就是收发消息，不需要太多的高级功能，所以Kafka是非常适合这种场景的。</p><h2 id="RabbitMQ">RabbitMQ</h2><h4 id="优势-v2">优势</h4><ul><li>RabbitMQ的优势在于可以保证数据不丢失，也能保证高可用性，即集群部署的时候部分机器宕机可以继续运行，然后支持部分高级功能，比如说死信队列，消息重试之类的，这些是他的优点。</li><li>在RocketMQ出现之前，国内大部分公司都从ActiveMQ切换到RabbitMQ来使用，包括很多一线互联网大厂，而且直到现在都有很多中小型公司在使用RabbitMQ，所以说RabbitMQ网上的资料相对多，而且社区非常活跃，更新频率非常快。</li></ul><h4 id="劣势-v2">劣势</h4><ul><li>RabbitMQ的吞吐量是比较低，一般就是每秒几万的级别，所以如果遇到特别特别高并发的情况下，支撑起来是有点困难的。</li><li>RabbitMQ进行集群扩展的时候（也就是加机器部署），比较麻烦。</li><li>另外还有一个较为致命的缺陷，就是他的开发语言是erlang，国内很少有精通erlang语言的工程师，因此也没办法去阅读他的源代码，甚至修改他的源代码。</li></ul><h4 id="总结-v2">总结</h4><p>现在行业里的一个情况是，很多BAT等一线互联网大厂都切换到使用更加优秀的RocketMQ了，但是很多中小型公司觉得RabbitMQ基本可以满足自己的需求还在继续使用中，因为中小型公司并不需要特别高的吞吐量，RabbitMQ已经足以满足他们的需求了，而且也不需要部署特别大规模的集群，也没必要去阅读和修改RabbitMQ的源码。</p><h2 id="RocketMQ">RocketMQ</h2><h4 id="优势-v3">优势</h4><ul><li><p>RocketMQ的吞吐量很高，单机可以达到10万QPS以上，而且可以保证高可用性，性能很高，而且支持通过配置保证数据绝对不丢失，可以部署大规模的集群，还支持各种高级的功能，比如说延迟消息、事务消息、消息回溯、死信队列、消息积压，等等。</p></li><li><p>RocketMQ是基于Java开发的，符合国内大多数公司的技术栈，很容易就可以阅读他的源码，甚至是修改他的源码。</p></li><li><p>RocketMQ是非常适合用在Java业务系统架构中的，因为他很高的性能表现，还有他的高阶功能的支持，可以让我们解决各种业务问题。</p></li></ul><h4 id="劣势-v3">劣势</h4><ul><li>RocketMQ也有一点美中不足的地方，就是经过调查发现，RocketMQ的官方文档相对简单一些，但是Kafka和RabbitMQ的官方文档就非常的全面和详细，这可能是RocketMQ目前唯一的缺点。</li></ul><h4 id="总结-v3">总结</h4><p>RocketMQ相对来说比较完美的一个消息中间件，在支撑高吞吐量的同时，而且还支持很多高阶的功能，很适合以Java为技术栈的公司使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本文主要对比常用的三种中间件优劣势，包含RocketMQ、Kafka、RabbitMQ。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;Kafka&quot;&gt;Kafka&lt;/h2&gt;
&lt;h4 id=&quot;优势&quot;&gt;优势&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Kafka的吞吐量几乎是行业里最</summary>
      
    
    
    
    <category term="RocketMQ" scheme="https://www.buzhidao.cc/categories/RocketMQ/"/>
    
    
    <category term="RocketMQ" scheme="https://www.buzhidao.cc/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件是什么?</title>
    <link href="https://www.buzhidao.cc/2020/05/13/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://www.buzhidao.cc/2020/05/13/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2020-05-13T06:59:34.000Z</published>
    <updated>2025-06-12T02:00:43.935Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、了解消息中间件之前先了解一下什么是“同步”">1、了解消息中间件之前先了解一下什么是“同步”?</h3><p>通常业务系统直接的调用如下图所示:</p><p><img src="http://qiniu.deveye.cn/blog/img/20210513184840.png" alt=""></p><p>假设系统A收到了一个请求，可能是用户通过浏览器或者APP发起的，这时候系统A收到请求后马上去调用系统B，然后系统B再把返回结果返回给系统A，系统A才能返回给用户。如下图所示：</p><p><img src="http://qiniu.deveye.cn/blog/img/20210513185350.png" alt=""></p><p>以上就是所谓的**“同步”**调用。这个同步的意思就是各个系统联动都是同步依次进行的，一个系统先动，然后立马带动另外一个系统一起动，最后大家依次干完活以后再返回结果。</p><h3 id="2、如何依托消息中间件实现异步？">2、如何依托消息中间件实现异步？</h3><p>我们往系统A和系统B之间加入一个消息中间件，简称为“MQ”，也就是消息队列。</p><p><img src="http://qiniu.deveye.cn/blog/img/20210513191451.png" alt=""></p><p>加入消息队列之后如何通信呢？</p><p>其实就是系统A执行完逻辑后给MQ中发送一条消息，然后就直接把结果返回给用户了。</p><p><strong>（注：前提是系统A返回给用户的结果不依赖于系统B的返回结果。假设系统B为短信系统，系统A向MQ发送一条发送短信的消息指令，系统A并不关心短信是否立即发送，只要最终在有效的时间内发送成功就行了。）</strong></p><p><img src="http://qiniu.deveye.cn/blog/img/20210513192217.png" alt=""></p><p>如上图所示，系统B什么时候执行自己的任务呢？</p><p>这时候系统B根据自己的情况，可能是系统A投递消息到MQ之后的1秒内，也可能是1分钟之后，多长时间都有可能，不管多长时间，系统B肯定会从MQ里获取到一条属于自己的消息。</p><p><img src="http://qiniu.deveye.cn/blog/img/20210513192841.png" alt=""></p><h3 id="3、消息中间件到底有什么用？">3、消息中间件到底有什么用？</h3><p>假设系统A要调用系统B干一些事，然后系统A先执行一些操作，需要耗费20ms，接着系统B执行一些操作，需要200ms，所以总共需要220ms。如下图所示：</p><p><img src="http://qiniu.deveye.cn/blog/img/20210513193519.png" alt=""></p><p>如果在系统A和系统中间加一个MQ呢？</p><p>系统A干完自己的事情耗时20ms，然后发一个消息到MQ耗时5ms，然后就直接返回结果给用户，总计耗时25ms。系统B从MQ中获取消息花费200ms和用户就没有关系了。所以用户只需等待25ms就收到结果了。如下图所示：</p><p><img src="http://qiniu.deveye.cn/blog/img/20210513214345.png" alt=""></p><p>假设系统A调用系统B出现故障呢？因为系统A调用系统B肯定返回异常，此时系统A是不是也得返回异常给用户？而系统A是不是还要去处理这个异常？</p><p><img src="http://qiniu.deveye.cn/blog/img/20210513214749.png" alt=""></p><p>这一切是因为系统A和系统B通过同步调用的模式耦合在一起，所以系统B一旦出现故障，很肯能影响系统A也有故障，而且系统A还得去关心系统B的故障，去处理对应的异常。</p><p>如果在系统A和系统B中间加一个消息中间件，系统A就不用关心系统B是否出现故障了，因为那是系统B自己的事，等系统B故障恢复以后，就继续执行它自己的事，此时就对系统A没任何影响了。</p><p><img src="http://qiniu.deveye.cn/blog/img/20210513215346.png" alt=""></p><p>为什么会有这样的效果呢？正式因为通过引入MQ，两个系统实现了异步化调用，也就实现了解耦，所以相互之间并没有任何影响。</p><h3 id="5、流量削峰">5、流量削峰</h3><p>假设系统A是不操作数据库的，因此只要多部署几台机器，就可以抗下每秒1万的请求，比如部署个20台机器，就可以轻松抗下每秒上万请求。</p><p>然后系统B是要操作一台数据库服务器的，那台数据库的上限是接收每秒6000请求，那么系统B无论部署多少台机器都没用，因为他依赖的数据库最多只能接收每秒6000请求。</p><p>如下图所示：</p><p><img src="http://qiniu.deveye.cn/blog/img/20210513215857.png" alt=""></p><p>假设现在有1万的QPS请求到了系统A，由于系统A部署了20台机器，所以可以抗住1万QPS。然后系统A会瞬间把1万QPS转发给系统B，假设系统B也抗住了1万QPS，但是系统B对数据库发起了1万QPS的请求，数据库一定会瞬间被压垮。</p><p>所以这时如果引入MQ，就可以解决这个问题了。MQ这个技术抗高并发的能力远远高于数据库，同样的机器配置下，如果数据库可以抗每秒6000请求，MQ至少可以抗每秒几万请求。</p><p>为什么呢？因为数据库复杂啊，他要能够支持你执行复杂的SQL语句，支持事务等复杂的机制，支持你对数据进行增删改查，听着简单，其实是很复杂的！所以一般数据库单服务器也就支撑每秒几千的请求。</p><p>所以只要你引入一个MQ，那么就可以让系统A把每秒1万请求都作为消息直接发送到MQ里，MQ可以轻松抗下来这每秒1万请求。</p><p><img src="http://qiniu.deveye.cn/blog/img/20210513220548.png" alt=""></p><p>接着，系统B只要慢慢的从MQ里获取消息然后执行数据库读写操作即可，这个获取消息的速度是系统B自己可以控制的，所以系统B完全可以用一个比较低的速率获取消息然后写入数据库，保证对数据库的QPS不要超过他的极限值6000。</p><p><img src="http://qiniu.deveye.cn/blog/img/20210513221033.png" alt=""></p><p>这个时候因为系统A发送消息到MQ很快，系统B从MQ消费消息很慢，所以MQ里自然会积压一些消息，不过不要紧，MQ一般都是基于磁盘来存储消息的，所以适当积压一些消息是可以的。当系统A的高峰过去，每秒可能就恢复到1000 QPS了，此时系统b还是以每秒6000QPS的速度获取消息写入数据库，那么自然MQ里积压的消息就会慢慢被消化掉了。</p><p>所以这就是MQ进行流量削峰的效果，<strong>系统A发送过来的每秒1万请求是一个流量洪峰，然后MQ直接给扛下来了，都存储自己本地磁盘，这个过程就是流量削峰的过程，瞬间把一个洪峰给削下来了，让系统B后续慢慢获取消息来处理。</strong></p><h3 id="6、总结">6、总结</h3><p><strong>消息中间件的主要作用就是削峰解耦，提升系统的响应速度。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1、了解消息中间件之前先了解一下什么是“同步”&quot;&gt;1、了解消息中间件之前先了解一下什么是“同步”?&lt;/h3&gt;
&lt;p&gt;通常业务系统直接的调用如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.deveye.cn/blog/img/2021051</summary>
      
    
    
    
    <category term="RocketMQ" scheme="https://www.buzhidao.cc/categories/RocketMQ/"/>
    
    
    <category term="RocketMQ" scheme="https://www.buzhidao.cc/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="https://www.buzhidao.cc/2019/09/03/%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.buzhidao.cc/2019/09/03/%E9%93%BE%E8%A1%A8/</id>
    <published>2019-09-03T10:23:11.000Z</published>
    <updated>2025-06-12T02:00:43.936Z</updated>
    
    <content type="html"><![CDATA[<h3 id="反转链表">反转链表</h3><p><img src="http://qiniu.deveye.cn/blog/img/20220302192225.gif" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">head := &amp;ListNode&#123;</span><br><span class="line">1, &amp;ListNode&#123;</span><br><span class="line">2, &amp;ListNode&#123;</span><br><span class="line">3, &amp;ListNode&#123;</span><br><span class="line">4, &amp;ListNode&#123;</span><br><span class="line">5, nil&#125;&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">for list := reverseList(head); list != nil; list = list.Next &#123;</span><br><span class="line">fmt.Println(list.Val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ListNode struct &#123;</span><br><span class="line">Val  int</span><br><span class="line">Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func reverseList(head *ListNode) *ListNode &#123;</span><br><span class="line">var cur, prev *ListNode = head, nil</span><br><span class="line">for cur != nil &#123;</span><br><span class="line">cur.Next, prev, cur = prev, cur, cur.Next</span><br><span class="line">&#125;</span><br><span class="line">return prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交换相邻两个节点">交换相邻两个节点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">head := &amp;ListNode&#123;</span><br><span class="line">1, &amp;ListNode&#123;</span><br><span class="line">2, &amp;ListNode&#123;</span><br><span class="line">3, &amp;ListNode&#123;</span><br><span class="line">4, nil&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">for list := swapPairs(head); list != nil; list = list.Next &#123;</span><br><span class="line">fmt.Println(list.Val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ListNode struct &#123;</span><br><span class="line">Val  int</span><br><span class="line">Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func swapPairs(head *ListNode) *ListNode &#123;</span><br><span class="line">if head == nil || head.Next == nil &#123;</span><br><span class="line">return head</span><br><span class="line">&#125;</span><br><span class="line">newHead := head.Next</span><br><span class="line">head.Next = swapPairs(newHead.Next)</span><br><span class="line">newHead.Next = head</span><br><span class="line">return newHead</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="判断链表是否有环">判断链表是否有环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">cycle := &amp;ListNode&#123;</span><br><span class="line">2, &amp;ListNode&#123;</span><br><span class="line">0, &amp;ListNode&#123;</span><br><span class="line">-4, nil&#125;&#125;&#125;</span><br><span class="line">cycle.Next.Next.Next = cycle</span><br><span class="line">head := &amp;ListNode&#123;</span><br><span class="line">3, cycle,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(hasCycle(head))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ListNode struct &#123;</span><br><span class="line">Val  int</span><br><span class="line">Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func hasCycle(head *ListNode) bool &#123;</span><br><span class="line">if head == nil || head.Next == nil &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">slow, fast := head, head</span><br><span class="line">for fast != nil &amp;&amp; fast.Next != nil &#123;</span><br><span class="line">slow, fast = slow.Next, fast.Next.Next</span><br><span class="line">if slow == fast &#123;</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;反转链表&quot;&gt;反转链表&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.deveye.cn/blog/img/20220302192225.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;ta</summary>
      
    
    
    
    <category term="算法" scheme="https://www.buzhidao.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://www.buzhidao.cc/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法之旅</title>
    <link href="https://www.buzhidao.cc/2019/09/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"/>
    <id>https://www.buzhidao.cc/2019/09/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/</id>
    <published>2019-09-03T09:33:14.000Z</published>
    <updated>2025-06-12T02:00:43.935Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/2019/09/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a></li><li><a href="/2019/09/03/%E9%93%BE%E8%A1%A8/">链表</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2019/09/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/&quot;&gt;排序算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2019/09/03/%E9%93%BE%E8%A1%A8/&quot;&gt;链表&lt;/a&gt;&lt;/li&gt;</summary>
      
    
    
    
    <category term="算法" scheme="https://www.buzhidao.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://www.buzhidao.cc/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://www.buzhidao.cc/2019/09/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://www.buzhidao.cc/2019/09/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2019-09-03T08:46:05.000Z</published>
    <updated>2025-06-12T02:00:43.935Z</updated>
    
    <content type="html"><![CDATA[<h3 id="排序算法">排序算法</h3><h4 id="冒泡排序">冒泡排序</h4><p>双层循环,每次循环将最大的值放到数组的最后面,外层循环n次,内层循环n-i次完成排序,时间复杂度为O(n²)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func bubbleSort(arr []int) &#123;</span><br><span class="line">for i := 0; i &lt; len(arr)-1; i++ &#123;</span><br><span class="line">for j := 0; j &lt; len(arr)-i-1; j++ &#123;</span><br><span class="line">if arr[j] &gt; arr[j+1] &#123;</span><br><span class="line">arr[j], arr[j+1] = arr[j+1], arr[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="选择排序">选择排序</h4><p>双层循环,每次循环找出arr[n-i]中最小的数与当前数进行交换,时间复杂度为O(n²)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func selectSort(arr []int) &#123;</span><br><span class="line">for i := 0; i &lt; len(arr)-1; i++ &#123;</span><br><span class="line">var min = i</span><br><span class="line">for j := i + 1; j &lt; len(arr); j++ &#123;</span><br><span class="line">if arr[min] &gt; arr[j] &#123;</span><br><span class="line">min = j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[i], arr[min] = arr[min], arr[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入排序">插入排序</h4><p>双层循环,类似打扑克牌调整牌的顺序,每次循环对当前数字顺序进行插入调整,时间复杂度为O(n²)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func insertionSort(arr []int) &#123;</span><br><span class="line">for i := range arr &#123;</span><br><span class="line">preIndex := i - 1</span><br><span class="line">current := arr[i]</span><br><span class="line">for preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current &#123;</span><br><span class="line">arr[preIndex+1] = arr[preIndex]</span><br><span class="line">preIndex -= 1</span><br><span class="line">&#125;</span><br><span class="line">arr[preIndex+1] = current</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="归并排序">归并排序</h4><p>分治的思想,时间复杂度O(N*logN)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func mergeSort(arr []int) []int &#123;</span><br><span class="line">if len(arr) &lt; 2 &#123;</span><br><span class="line">return arr</span><br><span class="line">&#125;</span><br><span class="line">i := len(arr) / 2</span><br><span class="line">left := mergeSort(arr[:i])</span><br><span class="line">right := mergeSort(arr[i:])</span><br><span class="line">result := merge(left, right)</span><br><span class="line">return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func merge(left, right []int) []int &#123;</span><br><span class="line">result := make([]int, 0)</span><br><span class="line">m, n := 0, 0</span><br><span class="line">l, r := len(left), len(right)</span><br><span class="line">for m &lt; l &amp;&amp; n &lt; r &#123;</span><br><span class="line">if left[m] &gt; right[n] &#123;</span><br><span class="line">result = append(result, right[n])</span><br><span class="line">n++</span><br><span class="line">&#125; else &#123;</span><br><span class="line">result = append(result, left[m])</span><br><span class="line">m++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">result = append(result, right[n:]...)</span><br><span class="line">result = append(result, left[m:]...)</span><br><span class="line">return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="堆排序">堆排序</h4><p><img src="http://qiniu.deveye.cn/blog/img/20220411162143.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package heap</span><br><span class="line"></span><br><span class="line">func sink(array []int, parentIndex int, length int) &#123;</span><br><span class="line">//保存父节点，用于最后的赋值</span><br><span class="line">temp := array[parentIndex]</span><br><span class="line">//左子节点</span><br><span class="line">childIndex := 2*parentIndex + 1</span><br><span class="line">//是否有左子节点</span><br><span class="line">for childIndex &lt; length &#123;</span><br><span class="line">//判断是否有右子节点，并且右子节点大于左子节点的值</span><br><span class="line">if childIndex+1 &lt; length &amp;&amp; array[childIndex+1] &gt; array[childIndex] &#123;</span><br><span class="line">childIndex++</span><br><span class="line">&#125;</span><br><span class="line">//如果父节点大于任何一个子节点的值直接跳出</span><br><span class="line">if temp &gt;= array[childIndex] &#123;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">array[parentIndex] = array[childIndex]</span><br><span class="line">parentIndex = childIndex</span><br><span class="line">childIndex = 2*childIndex + 1</span><br><span class="line">&#125;</span><br><span class="line">array[parentIndex] = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func heapSort(array []int) &#123;</span><br><span class="line">//构建大顶堆</span><br><span class="line">for i := (len(array) - 2) / 2; i &gt;= 0; i-- &#123;</span><br><span class="line">sink(array, i, len(array))</span><br><span class="line">&#125;</span><br><span class="line">//将堆顶元素和最后一个元素交换，数组长度i--(相当于循环删除根顶部元素，然后sink 调整最大堆)</span><br><span class="line">for i := len(array) - 1; i &gt; 0; i-- &#123;</span><br><span class="line">array[i], array[0] = array[0], array[i]</span><br><span class="line">sink(array, 0, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;排序算法&quot;&gt;排序算法&lt;/h3&gt;
&lt;h4 id=&quot;冒泡排序&quot;&gt;冒泡排序&lt;/h4&gt;
&lt;p&gt;双层循环,每次循环将最大的值放到数组的最后面,外层循环n次,内层循环n-i次完成排序,时间复杂度为O(n²)&lt;/p&gt;
&lt;figure class=&quot;highlight plain</summary>
      
    
    
    
    <category term="算法" scheme="https://www.buzhidao.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://www.buzhidao.cc/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>一份建议的Git Commit 模版</title>
    <link href="https://www.buzhidao.cc/2019/08/14/GitCommitTemplate/"/>
    <id>https://www.buzhidao.cc/2019/08/14/GitCommitTemplate/</id>
    <published>2019-08-14T08:36:00.000Z</published>
    <updated>2025-06-12T02:00:43.932Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型&gt;: (类型的值见下面描述) &lt;主题&gt; (最多50个字)</span><br></pre></td></tr></table></figure><blockquote><p>feat (新特性)<br>fix (bug修复)<br>docs (文档改动)<br>style (格式化, 缺失分号等; 不包括生产代码变动)<br>refactor (重构代码)<br>test (添加缺失的测试, 重构测试, 不包括生产代码变动)<br>chore (更新grunt任务等; 不包括生产代码变动)</p></blockquote><ul><li>主题和内容以一个空行分隔</li><li>主题限制为最大50个字</li><li>主题行大写</li><li>主题行结束不用标点</li><li>主题行使用祈使名</li><li>内容每行72个字</li><li>内容用于解释为什么和是什么,而不是怎么做</li><li>内容多行时以’-'分隔</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span</summary>
      
    
    
    
    <category term="Git" scheme="https://www.buzhidao.cc/categories/Git/"/>
    
    
    <category term="Git" scheme="https://www.buzhidao.cc/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git常用命令</title>
    <link href="https://www.buzhidao.cc/2019/02/18/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://www.buzhidao.cc/2019/02/18/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2019-02-18T13:40:02.000Z</published>
    <updated>2025-06-12T02:00:43.934Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://qiniu.deveye.cn/20210316200434.png" alt=""></p><h3 id="一、新建代码库">一、新建代码库</h3><blockquote><p><font color=gray># 在当前目录新建一个Git代码库</font><br>$ git init</p><p><font color=gray># 新建一个目录，将其初始化为Git代码库</font><br>$ git init [project-name]</p><p><font color=gray># 下载一个项目和它的整个代码历史</font><br>$ git clone [url]</p></blockquote><h3 id="二、配置">二、配置</h3><p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）</p><blockquote><p><font color=gray># 显示当前的Git配置</font><br>$ git config --list</p><p><font color=gray># 编辑Git配置文件</font><br>$ git config -e [–global]</p><p><font color=gray># 设置提交代码时的用户信息</font><br>$ git config [–global] <a href="http://user.name">user.name</a> &quot;[name]&quot;<br>$ git config [–global] user.email &quot;[email   address]&quot;</p></blockquote><h3 id="三、增加-删除文件">三、增加/删除文件</h3><blockquote><p><font color=gray># 添加指定文件到暂存区</font><br>$ git add [file1] [file2] …</p><p><font color=gray># 添加指定目录到暂存区，包括子目录</font><br>$ git add [dir]</p><p><font color=gray># 添加当前目录的所有文件到暂存区</font><br>$ git add .</p><p><font color=gray># 添加每个变化前，都会要求确认</font><br><font color=gray># 对于同一个文件的多处变化，可以实现分次提交</font><br>$ git add -p</p><p><font color=gray># 删除工作区文件，并且将这次删除放入暂存区</font><br>$ git rm [file1] [file2] …</p><p><font color=gray># 停止追踪指定文件，但该文件会保留在工作区</font><br>$ git rm --cached [file]</p><p><font color=gray># 改名文件，并且将这个改名放入暂存区</font><br>$ git mv [file-original] [file-renamed]</p></blockquote><h3 id="四、代码提交">四、代码提交</h3><blockquote><p><font color=gray># 提交暂存区到仓库区</font><br>$ git commit -m [message]</p><p><font color=gray># 提交暂存区的指定文件到仓库区</font><br>$ git commit [file1] [file2] … -m [message]</p><p><font color=gray># 提交工作区自上次commit之后的变化，直接到仓库区</font><br>$ git commit -a</p><p><font color=gray># 提交时显示所有diff信息</font><br>$ git commit -v</p><p><font color=gray># 使用一次新的commit，替代上一次提交</font><br><font color=gray># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</font><br>$ git commit --amend -m [message]</p><p><font color=gray># 重做上一次commit，并包括指定文件的新变化</font><br>$ git commit --amend [file1] [file2] …</p></blockquote><h3 id="五、分支">五、分支</h3><blockquote><p><font color=gray># 列出所有本地分支</font><br>$ git branch</p><p><font color=gray># 列出所有远程分支</font><br>$ git branch -r</p><p><font color=gray># 列出所有本地分支和远程分支</font><br>$ git branch -a</p><p><font color=gray># 新建一个分支，但依然停留在当前分支</font><br>$ git branch [branch-name]</p><p><font color=gray># 新建一个分支，并切换到该分支</font><br>$ git checkout -b [branch]</p><p><font color=gray># 新建一个分支，指向指定commit</font><br>$ git branch [branch] [commit]</p><p><font color=gray># 新建一个分支，与指定的远程分支建立追踪关系</font><br>$ git branch --track [branch] [remote-branch]</p><p><font color=gray># 切换到指定分支，并更新工作区</font><br>$ git checkout [branch-name]</p><p><font color=gray># 切换到上一个分支</font><br>$ git checkout -</p><p><font color=gray># 建立追踪关系，在现有分支与指定的远程分支之间</font><br>$ git branch --set-upstream [branch] [remote-branch]</p><p><font color=gray># 合并指定分支到当前分支</font><br>$ git merge [branch]</p><p><font color=gray># 选择一个commit，合并进当前分支</font><br>$ git cherry-pick [commit]</p><p><font color=gray># 删除分支</font><br>$ git branch -d [branch-name]</p><p><font color=gray># 删除远程分支</font><br>$ git push origin --delete [branch-name]<br>$ git branch -dr [remote/branch]</p></blockquote><h3 id="六、标签">六、标签</h3><blockquote><p><font color=gray># 列出所有tag</font><br>$ git tag</p><p><font color=gray># 新建一个tag在当前commit</font><br>$ git tag [tag]</p><p><font color=gray># 新建一个tag在指定commit</font><br>$ git tag [tag] [commit]</p><p><font color=gray># 删除本地tag</font><br>$ git tag -d [tag]</p><p><font color=gray># 删除远程tag</font><br>$ git push origin :refs/tags/[tagName]</p><p><font color=gray># 查看tag信息</font><br>$ git show [tag]</p><p><font color=gray># 提交指定tag</font><br>$ git push [remote] [tag]</p><p><font color=gray># 提交所有tag</font><br>$ git push [remote] --tags</p><p><font color=gray># 新建一个分支，指向某个tag</font><br>$ git checkout -b [branch] [tag]</p></blockquote><h3 id="七、查看信息">七、查看信息</h3><blockquote><p><font color=gray># 显示有变更的文件</font><br>$ git status</p><p><font color=gray># 显示当前分支的版本历史</font><br>$ git log</p><p><font color=gray># 显示commit历史，以及每次commit发生变更的文件</font><br>$ git log --stat</p><p><font color=gray># 搜索提交历史，根据关键词</font><br>$ git log -S [keyword]</p><p><font color=gray># 显示某个commit之后的所有变动，每个commit占据一行</font><br>$ git log [tag] HEAD --pretty=format:%s</p><p><font color=gray># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</font><br>$ git log [tag] HEAD --grep feature</p><p><font color=gray># 显示某个文件的版本历史，包括文件改名</font><br>$ git log --follow [file]<br>$ git whatchanged [file]</p><p><font color=gray># 显示指定文件相关的每一次diff</font><br>$ git log -p [file]</p><p><font color=gray># 显示过去5次提交</font><br>$ git log -5 --pretty --oneline</p><p><font color=gray># 显示所有提交过的用户，按提交次数排序</font><br>$ git shortlog -sn</p><p><font color=gray># 显示指定文件是什么人在什么时间修改过</font><br>$ git blame [file]</p><p><font color=gray># 显示暂存区和工作区的代码差异</font><br>$ git diff</p><p><font color=gray># 显示暂存区和上一个commit的差异</font><br>$ git diff --cached [file]</p><p><font color=gray># 显示工作区与当前分支最新commit之间的差异</font><br>$ git diff HEAD</p><p><font color=gray># 显示两次提交之间的差异</font><br>$ git diff [first-branch]…[second-branch]</p><p><font color=gray># 显示今天你写了多少行代码</font><br>$ git diff --shortstat &quot;@{0 day ago}&quot;</p><p><font color=gray># 显示某次提交的元数据和内容变化</font><br>$ git show [commit]</p><p><font color=gray># 显示某次提交发生变化的文件</font><br>$ git show --name-only [commit]</p><p><font color=gray># 显示某次提交时，某个文件的内容</font><br>$ git show [commit]:[filename]</p><p><font color=gray># 显示当前分支的最近几次提交</font><br>$ git reflog</p><p><font color=gray># 从本地master拉取代码更新当前分支：branch 一般为master</font><br>$ git rebase [branch]</p></blockquote><h3 id="八、远程同步">八、远程同步</h3><blockquote><p>$ git remote update  --更新远程仓储<br><font color=gray># 下载远程仓库的所有变动</font><br>$ git fetch [remote]</p><p><font color=gray># 显示所有远程仓库</font><br>$ git remote -v</p><p><font color=gray># 显示某个远程仓库的信息</font><br>$ git remote show [remote]</p><p><font color=gray># 增加一个新的远程仓库，并命名</font><br>$ git remote add [shortname] [url]</p><p><font color=gray># 取回远程仓库的变化，并与本地分支合并</font><br>$ git pull [remote] [branch]</p><p><font color=gray># 上传本地指定分支到远程仓库</font><br>$ git push [remote] [branch]</p><p><font color=gray># 强行推送当前分支到远程仓库，即使有冲突</font><br>$ git push [remote] --force</p><p><font color=gray># 推送所有分支到远程仓库</font><br>$ git push [remote] --all</p></blockquote><h3 id="九、撤销">九、撤销</h3><blockquote><p><font color=gray># 恢复暂存区的指定文件到工作区</font><br>$ git checkout [file]</p><p><font color=gray># 恢复某个commit的指定文件到暂存区和工作区</font><br>$ git checkout [commit] [file]</p><p><font color=gray># 恢复暂存区的所有文件到工作区</font><br>$ git checkout .</p><p><font color=gray># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</font><br>$ git reset [file]</p><p><font color=gray># 重置暂存区与工作区，与上一次commit保持一致</font><br>$ git reset --hard</p><p><font color=gray># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</font><br>$ git reset [commit]</p><p><font color=gray># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</font><br>$ git reset --hard [commit]</p><p><font color=gray># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</font><br>$ git reset --keep [commit]</p><p><font color=gray># 新建一个commit，用来撤销指定commit<br># 后者的所有变化都将被前者抵消，并且应用到当前分支</font><br>$ git revert [commit]</p><p><font color=gray># 暂时将未提交的变化移除，稍后再移入</font><br>$ git stash<br>$ git stash pop</p></blockquote><h3 id="十、其他">十、其他</h3><blockquote><p><font color=gray># 生成一个可供发布的压缩包</font><br>$ git archive</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://qiniu.deveye.cn/20210316200434.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、新建代码库&quot;&gt;一、新建代码库&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font color=gray&gt;# 在当前目录新建</summary>
      
    
    
    
    <category term="Git" scheme="https://www.buzhidao.cc/categories/Git/"/>
    
    
    <category term="Git" scheme="https://www.buzhidao.cc/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Nginx基本配置</title>
    <link href="https://www.buzhidao.cc/2019/01/18/Nginx%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.buzhidao.cc/2019/01/18/Nginx%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</id>
    <published>2019-01-18T02:50:25.000Z</published>
    <updated>2025-06-12T02:00:43.933Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Nginx-常用操作整理">1. Nginx 常用操作整理</h3><h4 id="1-1-启动-Nginx">1.1 启动 Nginx</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sbin/nginx</span><br></pre></td></tr></table></figure><h4 id="1-2-停止-Nginx">1.2 停止 Nginx</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./sbin/nginx -s stop</span><br><span class="line">./sbin/nginx -s quit</span><br><span class="line">-s 都是采用向 Nginx 发送信号的方式。</span><br></pre></td></tr></table></figure><h4 id="1-3-重载-Nginx">1.3 重载 Nginx</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sbin/nginx -s reload</span><br></pre></td></tr></table></figure><h4 id="1-4-指定配置文件">1.4 指定配置文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sbin/nginx -c /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><h4 id="1-5-配置语法检查">1.5 配置语法检查</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./sbin/nginx -t /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line">常规用法： ./sbin/nginx -tc /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><h3 id="2-配置文件详解">2. 配置文件详解</h3><p>Nginx配置文件的分块下，基本就分为以下几块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">main # 全局设置</span><br><span class="line">events &#123; # Nginx工作模式</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">http &#123; # http设置</span><br><span class="line">    ....</span><br><span class="line">    upstream myproject &#123; # 负载均衡服务器设置</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">    server  &#123; # 主机设置</span><br><span class="line">        ....</span><br><span class="line">        location &#123; # URL匹配</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server  &#123;</span><br><span class="line">        ....</span><br><span class="line">        location &#123;</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-main模块">2.1 main模块</h4><p>下面是一个main区域，它是一个全局的设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">user nobody nobody;</span><br><span class="line">worker_processes 2;</span><br><span class="line">error_log /usr/local/var/log/nginx/error.log notice;</span><br><span class="line">pid /usr/local/var/run/nginx/nginx.pid;</span><br><span class="line">worker_rlimit_nofile 1024;</span><br></pre></td></tr></table></figure><blockquote><p>user 来指定Nginx Worker进程运行用户以及用户组，默认由nobody账号运行。</p><p>worker_processes 来指定了Nginx要开启的子进程数。每个Nginx进程平均耗费10M~12M内存。根据经验，一般指定1个进程就足够了，如果是多核CPU，建议指定和CPU的数量一样的进程数即可。我这里写2，那么就会开启2个子进程，总共3个进程。</p><p>error_log 来定义全局错误日志文件。日志输出级别有debug、info、notice、warn、error、crit可供选择，其中，debug输出日志最为最详细，而crit输出日志最少。</p><p>pid 来指定进程id的存储文件位置。</p><p>worker_rlimit_nofile 来指定一个nginx进程可以打开的最多文件描述符数目，这里是65535，需要使用命令“ulimit -n 65535”来设置。</p></blockquote><h4 id="2-2-events模块">2.2 events模块</h4><p>events模块来用指定nginx的工作模式和工作模式及连接数上限，一般是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    use kqueue; #mac平台</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>use 用来指定Nginx的工作模式。Nginx支持的工作模式有select、poll、kqueue、epoll、rtsig和/dev/poll。其中select和poll都是标准的工作模式，kqueue和epoll是高效的工作模式，不同的是epoll用在Linux平台上，而kqueue用在BSD系统中，因为Mac基于BSD,所以Mac也得用这个模式，对于Linux系统，epoll工作模式是首选。</p><p>worker_connections 用于定义Nginx每个进程的最大连接数，即接收前端的最大请求数，默认是1024。最大客户端连接数由worker_processes和worker_connections决定，即Max_clients = worker_processes * worker_connections，在作为反向代理时，Max_clients变为：Max_clients = worker_processes * worker_connections / 4。</p><p>进程的最大连接数受Linux系统进程的最大打开文件数限制，在执行操作系统命令“ulimit -n 65536”后worker_connections的设置才能生效。</p></blockquote><h4 id="2-3-http模块">2.3 http模块</h4><p>http模块可以说是最核心的模块了，它负责HTTP服务器相关属性的配置，它里面的server和upstream子模块，至关重要，等到反向代理和负载均衡以及虚拟目录等会仔细说。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include mime.types;</span><br><span class="line">    default_type application/octet-stream;</span><br><span class="line">    log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                    &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                    &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line">    access_log /usr/local/var/log/nginx/access.log  main;</span><br><span class="line">    sendfile on;</span><br><span class="line">    tcp_nopush on;</span><br><span class="line">    tcp_nodelay on;</span><br><span class="line">    keepalive_timeout 10;</span><br><span class="line">    #gzip on;</span><br><span class="line">    upstream myproject &#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-1-include">2.3.1 include</h5><blockquote><p>用来设定文件的mime类型,类型在配置文件目录下的mime.type文件定义，来告诉nginx来识别文件类型。</p></blockquote><h5 id="2-3-2-default-type">2.3.2 default_type</h5><blockquote><p>设定了默认的类型为二进制流，也就是当文件类型未定义时使用这种方式，例如在没有配置asp的locate 环境时，Nginx是不予解析的，此时，用浏览器访问asp文件就会出现下载窗口了。</p></blockquote><h5 id="2-3-3-log-format">2.3.3 log_format</h5><blockquote><p>用于设置日志的格式，和记录哪些参数，这里设置为main，刚好用于access_log来纪录这种类型。</p></blockquote><h5 id="2-3-4-access-log">2.3.4 access_log</h5><blockquote><p>用来纪录每次的访问日志的文件地址，后面的main是日志的格式样式，对应于log_format的main。</p></blockquote><h5 id="2-3-5-sendfile">2.3.5 sendfile</h5><blockquote><p>用于开启高效文件传输模式。将tcp_nopush和tcp_nodelay两个指令设置为on用于防止网络阻塞。</p></blockquote><h5 id="2-3-6-keepalive-timeout">2.3.6 keepalive_timeout</h5><blockquote><p>设置客户端连接保持活动的超时时间。在超过这个时间之后，服务器会关闭该连接。</p></blockquote><h4 id="6-4-server模块">6.4 server模块</h4><p>server模块是http的子模块，它用来定一个虚拟主机，我们先讲最基本的配置，这些在后面再讲。我们看一下一个简单的server是如何做的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    server_name localhost 192.168.12.10 www.yangyi.com;</span><br><span class="line">    # 全局定义，如果都是这一个目录，这样定义最简单。</span><br><span class="line">    root   /Users/yangyi/www;</span><br><span class="line">    index  index.php index.html index.htm;</span><br><span class="line">    charset utf-8;</span><br><span class="line">    access_log  usr/local/var/log/host.access.log  main;</span><br><span class="line">    error_log  usr/local/var/log/host.error.log  error;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>server 标志定义虚拟主机开始。</p><p>listen 用于指定虚拟主机的服务端口。</p><p>server_name 用来指定IP地址或者域名，多个域名之间用空格分开。</p><p>root 表示在这整个server虚拟主机内，全部的root web根目录。注意要和locate {}下面定义的区分开来。</p><p>index 全局定义访问的默认首页地址。注意要和locate {}下面定义的区分开来。</p><p>charset 用于设置网页的默认编码格式。</p><p>access_log 用来指定此虚拟主机的访问日志存放路径，最后的main用于指定访问日志的输出格式。</p></blockquote><h4 id="2-5-location模块">2.5 location模块</h4><p>location模块是nginx中用的最多的，也是最重要的模块了，什么负载均衡啊、反向代理啊、虚拟域名啊都与它相关。</p><p>location根据它字面意思就知道是来定位的，定位URL，解析URL，所以，它也提供了强大的正则匹配功能，也支持条件判断匹配，用户可以通过location指令实现Nginx对动、静态网页进行过滤处理。像我们的php环境搭建就是用到了它。</p><h5 id="2-5-1-我们先来看这个，设定默认首页和虚拟机目录">2.5.1 我们先来看这个，设定默认首页和虚拟机目录</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root   /Users/yangyi/www;</span><br><span class="line">    index  index.php index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>location / 表示匹配访问根目录。</p><p>root 指令用于指定访问根目录时，虚拟主机的web目录，这个目录可以是相对路径（相对路径是相对于nginx的安装目录）。也可以是绝对路径。</p><p>index 用于设定我们只输入域名后访问的默认首页地址，有个先后顺序：index.php index.html index.htm，如果没有开启目录浏览权限，又找不到这些默认首页，就会报403错误。</p></blockquote><h5 id="2-5-2-location-还有一种方式就是正则匹配">2.5.2 location 还有一种方式就是正则匹配</h5><p>下面这个例子是运用正则匹配来链接php。我们之前搭建环境也是这样做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    root           /Users/yangyi/www;</span><br><span class="line">    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    fastcgi_index  index.php;</span><br><span class="line">    include        fastcgi.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>.php$ 熟悉正则的我们直到，这是匹配.php结尾的URL，用来解析php文件。里面的root也是一样，用来表示虚拟主机的根目录。<br>fastcgi_pass 链接的是php-fpm的地址。其他几个参数我们以后再说。</p><p>location 还有其他用法，等讲到实例的时候，再看吧。</p></blockquote><h4 id="2-6-upstream模块">2.6 upstream模块</h4><p>upstream 模块负责负载均衡模块，通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。先学习怎么用，具体的使用实例以后再说。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">upstream deveye.cn&#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 192.168.12.1:80;</span><br><span class="line">    server 192.168.12.2:80 down;</span><br><span class="line">    server 192.168.12.3:8080  max_fails=3  fail_timeout=20s;</span><br><span class="line">    server 192.168.12.4:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，<a href="http://xn--upstreamiyangyi-7e3xouw5c9yc706c1jlfyemo5arx4bba4380k2ktarn6g3z2ap3oc8b41d.com">通过upstream指令指定了一个负载均衡器的名称iyangyi.com</a>。这个名称可以任意指定，在后面需要的地方直接调用即可。里面是ip_hash这是其中的一种负载均衡调度算法，下面会着重介绍。紧接着就是各种服务器了。用server关键字表识，后面接ip。<br><strong>Nginx的负载均衡模块目前支持4种调度算法：</strong></p><ol><li><p>weight 轮询（默认）。每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响。weight，指定轮询权值，weight值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下。</p></li><li><p>ip_hash。每个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题。</p></li><li><p>fair（第三方）。比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块。</p></li><li><p>url_hash（第三方）。按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身是不支持url_hash的，如果需要使用这种调度算法，必须安装Nginx的hash软件包。</p></li></ol><p>在HTTP Upstream模块中，可以通过server指令指定后端服务器的IP地址和端口，同时还可以设定每个后端服务器在负载均衡调度中的状态。常用的状态有：</p><ol><li><p>down，表示当前的server暂时不参与负载均衡。</p></li><li><p>backup，预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻。</p></li><li><p>max_fails，允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误。</p></li><li><p>fail_timeout，在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用。</p></li></ol><p><em>注意：当负载调度算法为ip_hash时，后端服务器在负载均衡调度中的状态不能是weight和backup。</em></p><blockquote><p>转载自 ：<a href="https://www.jianshu.com/p/f04733896a48">https://www.jianshu.com/p/f04733896a48</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-Nginx-常用操作整理&quot;&gt;1. Nginx 常用操作整理&lt;/h3&gt;
&lt;h4 id=&quot;1-1-启动-Nginx&quot;&gt;1.1 启动 Nginx&lt;/h4&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas</summary>
      
    
    
    
    <category term="nginx" scheme="https://www.buzhidao.cc/categories/nginx/"/>
    
    
    <category term="nginx" scheme="https://www.buzhidao.cc/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Redis复制</title>
    <link href="https://www.buzhidao.cc/2018/07/07/Redis%E5%A4%8D%E5%88%B6/"/>
    <id>https://www.buzhidao.cc/2018/07/07/Redis%E5%A4%8D%E5%88%B6/</id>
    <published>2018-07-07T01:04:12.000Z</published>
    <updated>2025-06-12T02:00:43.934Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Replication">Replication</h3><p>Redis使用主从复制非常简单，它允许从实例成为主实例的副本，每当链接断开时，从节点将自动重新连接到主服务器上。并且无论主服务器发生什么情况，从节点都尝试完全复制所有数据。</p><h3 id="Redis主从复制使用以下三种机制：">Redis主从复制使用以下三种机制：</h3><ul><li>当主从实例连接良好时，主节点向从节点发送<strong>命令流</strong>来进行更新，是为了复制由于Key过期或回收等其他操作对数据产生影响。</li><li>当主从实例断开时，从节点重新连接后只会尝试获取链接断开期间错开的命令流。</li><li>如果无法进行部分重新同步，则会要求完全重新同步。</li></ul><blockquote><p>默认情况下，Redis会使用<em><strong>异步复制</strong></em>，Redis从节点会异步地确认接收的数据。因此，主节点不会等待从节点处理完成。但是，如果需要知道从节点都处理了那些命令，也可以选择同步复制。</p></blockquote><h3 id="Redis-复制的几个特征：">Redis 复制的几个特征：</h3><ol><li>Redis是使用异步复制</li><li>一个主节点可以有多个从节点</li><li>从节点还可以有子节点，从Redis 4.0开始，所有子节点将从主节点接收完全相同的复制流。</li><li>Redis主从复制是无阻塞的，意味着在进行复制或同步是仍然可以进行数据查询</li><li>复制既可以用于可伸缩性，也可以用于只读查询的多个副本（读写分离）</li><li>可以配置主节点不进行数据保存或只启用AOF，然后将数据保存到副本，但是注意:当服务器重启后，从节点服务器重新同步数据时，同时会清空从节点数据。</li></ol><h3 id="Redis-复制的原理：">Redis 复制的原理：</h3><p>每个Redis Master 节点都有一个replication ID:这是一个较大的伪随机字符串，用于标记当前数据集。每个Master 还有一个偏移量，该偏移量会针对复制流中要发送到副本的每个字节的增量而增加。<br>以便更新副本的状态。即使未连接任何副本，复制偏移也会增加。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=39.105.157.176,port=6379,state=online,offset=61238,lag=0</span><br><span class="line"># 主 Replication ID</span><br><span class="line">master_replid:649255ffb2183786d00203aa51715169b06f4f47</span><br><span class="line"># 副 Replication ID</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:61238</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:61238</span><br></pre></td></tr></table></figure><p>当从节点连接主节点时，会使用<code>PSYNC</code>命令来发送当前旧的主节点的Replication ID和offset，这样主节点只会同步相差的数据量，如果主节点缓冲区的副本引用（Replication ID）不存在，则会进行全量同步。</p><h4 id="全量同步的工作流程如下：">全量同步的工作流程如下：</h4><p>主节点开始后台生成RDB文件。同时，它开始缓冲从客户端收到的所有新写入命令。后台保存完成后，主数据库将数据库文件传输到从节点，从节点将其保存在磁盘上，然后将其加载到内存中。然后，主服务器将所有缓冲的命令发送到副本。</p><h3 id="Replication-ID-说明：">Replication ID 说明：</h3><p>如果两个实例具有相同的Replication ID和offset，则它们具有完全相同的数据。但是为什么会有两个Replication ID(主和副)？</p><p style="text-indent:2em">因为两个实例A和B具有相同的Replication ID，但一个实例的offset为1000，另一个实例的offset为1023，则意味着第一个实例缺少应用于数据集的某些命令。这也意味着，仅通过应用一些命令，A即可达到与B完全相同的状态。</p><p style="text-indent:2em">Redis实例具有两个Replication ID的原因是由于副本被提升为主副本。故障转移后，升级后的副本仍需要记住其过去的Replication ID，因为该Replication ID是以前的主副本之一。这样，当其他副本将与新的主副本同步时，它们将尝试使用旧的主Replication ID执行部分重新同步。因为将副本提升为主副本时，它会将其辅助ID设置为其主ID，并记住发生此ID切换时的offset。稍后它将选择一个新的随机Replication ID，因为新的历史记录开始了。处理新的副本连接时，主机将其ID和offset与当前ID和辅助ID相匹配（为安全起见，直到给定的偏移量）。简而言之，这意味着在故障转移后，连接到新提升的主服务器的副本不必执行完全同步。</p><h3 id="无盘复制">无盘复制</h3><p>通常，完全重新同步需要在磁盘上创建RDB文件，然后从磁盘重新加载相同的RDB，以便为副本提供数据。<br>但是对于硬盘速度慢，但是在内网环境下，可以采用无盘复制，这样可以直接通过Socket将RDB发送给从节点，而无需使用硬盘作为中间存储。</p><h3 id="配置">配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof 192.168.1.1 6379</span><br></pre></td></tr></table></figure><p>也可以使用<code>REPLICAOF</code>命令进行同步。<br>可以使用<code>repl-diskless-sync</code>配置参数启用无盘复制。在<code>repl-diskless-sync-delay </code>参数控制第一个副本之后，为了等待更多副本到达而开始传输的延迟。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth &lt;password&gt;</span><br></pre></td></tr></table></figure><p>设置主节点的密码，也可以使用redis-cli输入<code>config set masterauth &lt;password&gt;</code>进行设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在当前至少有N个副本连接到主服务器时才接受写查询</span><br><span class="line">min-replicas-to-write &lt;number of replicas&gt;</span><br><span class="line"># 在有N个副本延迟少于M秒时，则接受写入</span><br><span class="line">min-replicas-max-lag &lt;number of seconds&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Replication&quot;&gt;Replication&lt;/h3&gt;
&lt;p&gt;Redis使用主从复制非常简单，它允许从实例成为主实例的副本，每当链接断开时，从节点将自动重新连接到主服务器上。并且无论主服务器发生什么情况，从节点都尝试完全复制所有数据。&lt;/p&gt;
&lt;h3 id=&quot;</summary>
      
    
    
    
    <category term="Redis" scheme="https://www.buzhidao.cc/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://www.buzhidao.cc/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化</title>
    <link href="https://www.buzhidao.cc/2018/07/06/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://www.buzhidao.cc/2018/07/06/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2018-07-06T14:56:00.000Z</published>
    <updated>2025-06-12T02:00:43.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis的持久化机制-RDB">Redis的持久化机制-RDB</h2><h3 id="1-什么是RDB">1.什么是RDB</h3><p>The RDB persistence performs point-in-time snapshots of your dataset at specified intervals.(RDB持久化是以指定的时间间隔执行数据集的时间点快照。)<br>简单来说，RDB是每隔一段时间，会把内存中的数据写入磁盘的临时文件作为快照，恢复时把快照文件读取到内存中。如果机器宕机，那么内存中的数据就会丢失，使用RDB机制后，重启后数据会恢复。</p><h3 id="2-备份与恢复">2.备份与恢复</h3><p>内存备份 --&gt; <font color="#e58484">磁盘临时文件</font><br>临时文件 --&gt; <font color="#e58484">恢复到内存</font></p><h3 id="3-RDB优劣势">3.RDB优劣势</h3><ul><li><p><strong>优势</strong></p><ol><li>每隔一段时间全量备份</li><li>容灾简单，适合进行远程冷备份</li><li>子进程备份的时候，主进程不会有任何IO操作（不会有写入或修改），保证备份数据的完整性</li><li>相对AOF来说，当有更大的文件时候可以快速重启恢复</li></ol></li><li><p><strong>劣势</strong></p><ol><li>发生故障时，可能会丢失最后一次备份数据</li><li>子进程所占用的内存会和父进程一模一样，会造成CPU负担</li><li>由于定时全量备份是重量级操作，所以对于实时备份，就无法处理了</li></ol></li></ul><h3 id="4-RDB的配置">4.RDB的配置</h3><ol><li>保存位置可以自定义配置:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /var/redis/6379/dump.rdb</span><br></pre></td></tr></table></figure><ol start="2"><li>保存机制</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">#   900秒（15分钟）后，如果至少有 1 个Key发生改变</span><br><span class="line">#   300秒（5分钟）后，如果至少有 10 个Key发生改变</span><br><span class="line">#   60秒（1分钟）后，如果至少有 10000 个Key发生改变</span><br><span class="line"></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><h2 id="Redis的持久化机制-AOF">Redis的持久化机制-AOF</h2><h3 id="1-什么是AOF">1.什么是AOF</h3><p>The AOF persistence logs every write operation received by the server, that will be played again at server startup, reconstructing the original dataset. Commands are logged using the same format as the Redis protocol itself, in an append-only fashion. Redis is able to rewrite the log in the background when it gets too big.</p><p>AOF持久化会记录服务器接收到的每个写入操作，这些操作将在服务器启动时再次执行，以重新构建原始的数据。命令记录的格式与Redis协议本身的格式相同，采用追加方式。当日志文件过大时，Redis可以在后台进行<code>rewrite</code>。</p><h3 id="2-备份与恢复-v2">2.备份与恢复</h3><p>日志备份 --&gt; <font color="#e58484">命令追加方式</font><br>日志文件 --&gt; <font color="#e58484">根据命令日志文件重新构建</font></p><h3 id="3-AOF优劣势">3.AOF优劣势</h3><ul><li><strong>优势</strong><ol><li>使用AOF数据持久化更加完整</li><li>可以使用不同的fsync策略，使用默认策略fsync时，每秒的写入性能仍然很好（fsync是使用后台线程执行的，并且在没有进行fsync的情况下，主线程将尽力执行写入操作）但是会损失一秒的写入时间</li><li>AOF是使用日志追加的方式，如果断电或其他原因导致日志只写了一半，可以使用<code>redis-check-aof</code>工具进行修复</li><li>Redis太大时，Redis可以在后台自动重写AOF。 Redis继续追加到旧文件时，会生成一个新的文件，其中包含创建当前数据集<strong>所需的最少操作集</strong>，一旦准备好第二个文件，Redis会切换这两个文件并开始追加到新的那一个</li><li>即使使用<code>FLUSHALL</code>命令清空了所有数据，也可以通过修改AOF文件进行数据恢复</li></ol></li><li><strong>劣势</strong><ol><li>AOF相比RDB占用空间更大</li><li>使用fsync策略后，相比RDB性能差一些</li><li>当服务器宕机后，使用AOF恢复的数据可能不完整</li></ol></li></ul><h3 id="4-AOF的配置">4.AOF的配置</h3><ol><li>开启AOF</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><ol start="2"><li>配置fsync策略</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># If unsure, use &quot;everysec&quot;.</span><br><span class="line"># 如果不确定，推荐使用 &quot;everysec&quot;</span><br><span class="line"></span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br></pre></td></tr></table></figure><ol start="3"><li>AOF rewrite配置</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 设置一个百分比</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"># 设置AOF 的最小大小</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure><ol start="4"><li>Redis 启动加载配置</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 优先加载AOF 文件</span><br><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure><h2 id="两种持久化方式改如何选择">两种持久化方式改如何选择</h2><ul><li>如果对数据可靠性要求很高，则应同时使用两种持久性方式。</li><li>如果在灾难情况下仍然可以承受几分钟的数据丢失，则可以仅使用RDB。</li><li>不推荐单独使用AOF，因为AOF在数据恢复时，有时候会出现Bugs。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis的持久化机制-RDB&quot;&gt;Redis的持久化机制-RDB&lt;/h2&gt;
&lt;h3 id=&quot;1-什么是RDB&quot;&gt;1.什么是RDB&lt;/h3&gt;
&lt;p&gt;The RDB persistence performs point-in-time snapshots of you</summary>
      
    
    
    
    <category term="Redis" scheme="https://www.buzhidao.cc/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://www.buzhidao.cc/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis安装与配置</title>
    <link href="https://www.buzhidao.cc/2018/07/06/Redis%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.buzhidao.cc/2018/07/06/Redis%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</id>
    <published>2018-07-06T14:22:42.000Z</published>
    <updated>2025-06-12T02:00:43.934Z</updated>
    
    <content type="html"><![CDATA[<h3 id="下载">下载</h3><ol><li>从<a href="http://www.redis.io">Redis官网</a>下载redis 最新稳定版本</li><li>解压到 /usr/local/ 目录下</li></ol><h3 id="安装">安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make test &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>make时报如下错误:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zmalloc.h:50:31: error: jemalloc/jemalloc.h: No such file or directory</span><br><span class="line">zmalloc.h:55:2: error: #error &quot;Newer version of jemalloc required&quot;</span><br><span class="line">make[1]: *** [adlist.o] Error 1</span><br><span class="line">make[1]: Leaving directory `/data0/src/redis-2.6.2/src&#x27;</span><br><span class="line">make: *** [all] Error 2</span><br></pre></td></tr></table></figure><p>原因是jemalloc重载了Linux下的ANSI C的malloc和free函数。<br>解决办法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make MALLOC=libc</span><br></pre></td></tr></table></figure><h3 id="redis-生产环境启动方案">redis 生产环境启动方案</h3><ol><li>redis utils 目录下，有个redis_init_script脚本</li><li>将redis_init_script脚本拷贝到linux的/etc/init.d 目录中，将redis_init_script重命名为redis_6379,   6379是我们希望redis 的实例端口号</li><li>创建两个目录 /etc/redis (存放redis 配置的目录), /var/redis/6379 (存放redis的持久文件)</li><li>修改redis.conf配置文件（默认在根目录下），拷贝到/etc/redis目录下，修改名称为6379.conf</li><li>修改redis.conf中的部分配置为生产环境</li></ol><table><thead><tr><th>参数</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>daemonize</td><td>yes</td><td>让redis以daemon进程运行</td></tr><tr><td>pidfile</td><td>/var/run/redis_6379.pid</td><td>设置redis的pid文件位置</td></tr><tr><td>port</td><td>6379</td><td>设置redis的监听端口号</td></tr><tr><td>dir</td><td>/var/redis/6379</td><td>设置持久化文件的存储位置</td></tr></tbody></table><ol start="6"><li>启动redis:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/init.d </span><br><span class="line">chmod 777 redis_6379 </span><br><span class="line">./redis_6379 start</span><br></pre></td></tr></table></figure><ol start="7"><li>确认redis 进程是否启动: <code>ps -ef  |  grep redis</code></li><li>让redis跟随系统启动自动启动，在redis_6379 脚本中，最上面加入两行注释</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># chkconfig:    2345 90 10</span><br><span class="line"># description: Redis is a persistent key-value database</span><br><span class="line">chkconfig redis_6379 on   </span><br></pre></td></tr></table></figure><h3 id="主从架构（主节点和从节点最好保证一致的版本）">主从架构（主节点和从节点最好保证一致的版本）</h3><ol><li>在 slave node 上配置:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof 192.168.1.1 6379</span><br></pre></td></tr></table></figure><ol start="2"><li>强制读写分离</li></ol><p>基于主从复制架构，实现读写分离<br>redis slave node 只读，默认开启，<code>slave-read-only</code><br>开启了只读的redis slave node，会拒绝所有的写操作，这样可以强制搭建成读写分离架构</p><ol start="3"><li><p>集成安全认证<br>master 上启用安全认证策略，<code>requirepass</code><br>master 连接口令 <code>masterauth</code></p></li><li><p>读写分离架构的测试<br>先启动主节点，再启动从节点，在搭建生产环境的时候，不要忘记修改一个配置：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1</span><br></pre></td></tr></table></figure><p>每个redis.conf 中的bind <code>127.0.0.1</code> -&gt; bind自己的ip，并且防火墙打开6379端口</p><h3 id="redis-cli的使用">redis-cli的使用</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>redis-cli shutdown</td><td>连接本机的6379端口停止redis进程</td></tr><tr><td>redis-cli -h 127.0.0.1 -p 6379</td><td>指定要连接的ip和端口号</td></tr><tr><td>redis-cli ping</td><td>ping redis的端口，看是否正常</td></tr><tr><td>redis-cli</td><td>进入交互式命令行</td></tr><tr><td>set k1 v1</td><td>设置一个key:value</td></tr><tr><td>get k1</td><td>获取key的值</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;下载&quot;&gt;下载&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;从&lt;a href=&quot;http://www.redis.io&quot;&gt;Redis官网&lt;/a&gt;下载redis 最新稳定版本&lt;/li&gt;
&lt;li&gt;解压到 /usr/local/ 目录下&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;安装&quot;&gt;安装</summary>
      
    
    
    
    <category term="Redis" scheme="https://www.buzhidao.cc/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://www.buzhidao.cc/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>随手记</title>
    <link href="https://www.buzhidao.cc/2018/06/06/%E9%9A%8F%E6%89%8B%E8%AE%B0/"/>
    <id>https://www.buzhidao.cc/2018/06/06/%E9%9A%8F%E6%89%8B%E8%AE%B0/</id>
    <published>2018-06-06T06:40:23.000Z</published>
    <updated>2025-06-12T02:00:43.936Z</updated>
    
    <content type="html"><![CDATA[<h3 id="三个有启发的学习方法">三个有启发的学习方法</h3><ul><li><p>看似最笨的学习方法----笔记和记忆力----偏偏造就了最高的开发效率。</p></li><li><p>如果没有对旧事物进行大量练习，你不太可能发现新事物</p></li><li><p>要想多学，就必须能在学习中得到快乐。做到这一点的唯一方法，就是努力学习你最感兴趣的东西。</p></li></ul><p><a href="https://www.ruanyifeng.com/blog/2022/04/weekly-issue-202.html">https://www.ruanyifeng.com/blog/2022/04/weekly-issue-202.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;三个有启发的学习方法&quot;&gt;三个有启发的学习方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;看似最笨的学习方法----笔记和记忆力----偏偏造就了最高的开发效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果没有对旧事物进行大量练习，你不太可能发现新事物&lt;/p&gt;
&lt;/li&gt;
</summary>
      
    
    
    
    <category term="随手记" scheme="https://www.buzhidao.cc/categories/%E9%9A%8F%E6%89%8B%E8%AE%B0/"/>
    
    
    <category term="随手记" scheme="https://www.buzhidao.cc/tags/%E9%9A%8F%E6%89%8B%E8%AE%B0/"/>
    
  </entry>
  
</feed>
