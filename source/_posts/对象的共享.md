---
title: 对象的共享
date: 2019-05-27 08:56:49
tags: 多线程
categories: Java
---
### 可见性
可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。在单线程环境中，如果向某个变量先写入值，然后在没有其他写入操作的情况下读取这个变量，那么总能得到相同的值。这看起来很自然。然而，当读操作和写操作在不同的线程中执行，情况却并非如此，这听起来或许有些难以接受。通常，我们无法确保执行读操作的线程能实时的看到其他线程写入的值，有时甚至是根本不可能的事情。为了保证多个线程之间对内存写入操作的可见性，必须使用同步机制。

> 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。

#### 非原子的64位操作
当线程在没有同步的情况下读取变量时，可能会得到一个失效的值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性（out-of-thin-airsafety）。

非volatile类型的64位数值变量（double 和 long）JVM 允许将64位的读写操作分解成两个32位的操作。当读取一个非volatile类型的long变量时，如果该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值得低32位。因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非用关键字volatile来声明它们，或用锁保护起来。

#### 加锁与可见性   
内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果，如图所示。当线程A执行某个同步代码块时，线程B随后进入由一个锁保护的同步代码块，在这种情况下可以保证，在锁被释放之前，A看到的变量值在B获得锁后同样可以由B看到。换句话说，当线程B执行由锁保护的同步代码块时，可以看到线程A之前在同一个同步代码块中的所有操作结果。如果没有同步，那么就无法实现以上保证。
![](/img/2F193BE3-2A71-43E4-97D6-A3D01EC9FA4B.png)

> 加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有的线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在一个锁上同步。

### Volatile 变量
Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此读取volatile类型的变量时总会返回最新写入的值。

> 仅当volatile 变量能简化代码的实现以及对同步策略的验证时，才应该使用他们。如果在验证正确性需要对可见性进行复杂的判断，那么就不需要使用volatile变量。volatile变量的正确使用方式包括：确保他们自身状态的可见性，确保他们所引用对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生（例如：初始化或关闭）

![](/img/20190515-145535.png)

> 加锁机制既可以保证可见性又可以确保原子性，而volatile变量只能确保可见性。

当满足以下所有条件时，才应该使用volatile变量：
- 当变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
- 该变量不会与其他状态变量一起纳入不变性条件中。
- 在访问变量时不需要加锁。

### 发布与逸出

**“发布（Publish）”** 一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。例如，将一个指向该对象的引用保存到其他代码可以访问的地方，或者在某一个非私有的方法中返回该引用，或者将引用传递到其他类的方法中。在许多情况中，我们要确保对象及其内部状态不被发布。在某些情况下，我们又需要发布某个对象但如果在发布时要确保线程安全性，如果在对象构造完成之前就发布该对象，就会破坏线程安全性。当某个不应该发布的对象被发布时，这种情况被称为逸出（Escape）。

![](/img/20190515-164155.png)

![](/img/C1D89EAA17AC.png)

> 不要在构造过程中使this引用逸出。

如果想在构造函数中注册一个事件监听器或启动线程，那么可以使用一个私有的构造函数和一个公共的工厂方法，从而避免不正确的构造过程。

![](/img/20190515-170109.png)
