---
title: 线程复用：线程池
date: 2018-09-22 07:27:16
tags: JUC
categories: java
---
### 线程复用：线程池
&emsp;&emsp;多线程的软件设计方法确实可以最大限度地发挥现代多核处理器地计算性能，提高生产系统的吞吐量和性能。但是，若不加控制和管理随意使用线程，对系统的性能反而会产生不利的影响。   
&emsp;&emsp;一种最为简单的线程创建和回收方法类似如下代码：  
```
new Thread(new Runnable(){
  @Override
  public void run(){
    //do sth.
  }
}).start();
```
&emsp;&emsp;以上代码创建了一个线程，并在`run()`方法结束后，自动回收该线程。在简单的应用系统中，这段代码并没有太多问题。但是真实的生成环境中，系统由于真实环境的需要，可能会开启很多线程来支撑应用。而当线程数量过大时，反而会耗尽CPU和内存资源。   

&emsp;&emsp;首先，虽然与进程相比，线程是一种轻量级的工具，但其创建和关闭依然需要花费时间，如果为每一个小的任务都创建一个线程，很有可能出现创建和销毁线程所占用的时间大于该线程真实工作所消耗的时间的情况，反而会得不偿失。

&emsp;&emsp;其次，线程本身也是要占用内存空间的，大量的线程会抢占宝贵的内存资源，如果处理不当，可能会导致`Out of Memory`异常。即便没有，大量的线程回收也会给`GC`带来很大的压力，延长GC的停顿时间。

&emsp;&emsp;因此，对线程的使用必须掌握一个度，在有限的范围内，增加线程的数量可以明显提高系统的吞吐量，但一旦超出了这个范围，大量的线程只会拖垮应用系统。因此，在成产环境中使用线程，必须对其加以控制和管理。  

&emsp;&emsp;***注意：在实际生产环境中，线程的数量必须得到控制，盲目的大量创建线程对系统性能是有伤害的。***

### 什么是线程池

&emsp;&emsp;为了避免系统频繁的创建和销毁线程，我们可以让创建的线程进行复用。如果大家进行过数据库开发，对数据库的连接池应该不会陌生。为了避免每次数据库查询都重新建立和销毁数据库连接，我们可以使用数据库连接池维护一些数据库连接，让他们长期保持在一个激活状态。当系统需要使用数据库时，并不是创建一个新的连接，而是从连接池中获得一个可用的连接即可。反之，当需要关闭连接时，并不真的把连接关闭，而是将这个连接“还”给连接池即可。通过这种方式，可以节约不少创建和销毁对象的时间。  

&emsp;&emsp;线程池也是类似的概念。线程池中，总有那么几个活跃线程。当你需要使用线程时，可以从池子中随便拿一个空闲线程，当完成工作时，并不着急关闭线程，而是将这个线程退回到池子，方便其他地方使用。

### JDK对线程池的支持

Executor 框架提供了各种类型的线程池，主要有以下工厂方法：  
```
public static ExecutorService newFixedThreadPool(int nThreads);

public static ExecutorService newSingleThreadExecutor();

public static ExecutorService newCachedThreadPool();

public static ScheduledExecutorService newSingleThreadScheduledExecutor();

public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize);

```
以上工厂方法的具体说明如下：  
* ***newFixedThreadPool()***方法：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。

* ***newSingleThreadExecutor()***方法：该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。  

* ***newCachedThreadPool()***方法：该方法返回一个可根据实际情况调整线程数量的线程。线程池的线程数量不确定，但若有空闲线程可复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。

* ***newSingleThreadScheduledExecutor()***方法：该方法返回一个`ScheduledExecutorService`对象，线程池大小为***1***，`ScheduledExecutorService`接口在`ExecutorService`接口之上扩展了在给定时间执行某任务的功能，如在某个固定的延时之后执行，或周期性执行某个任务。

* ***newScheduledThreadPool()***方法：该方法也返回一个`ScheduledExecutorService`对象，但该线程池可以指定线程数量。

//loading
